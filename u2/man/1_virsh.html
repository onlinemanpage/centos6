<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 05:23:11 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>VIRSH(1) Virtualization Support VIRSH(1)</p>

<p>NAME virsh - management user interface</p>

<p>SYNOPSIS virsh [OPTION]... [COMMAND_STRING]</p>

<p>virsh [OPTION]... COMMAND [ARG]...</p>

<p>DESCRIPTION The virsh program is the main interface for
managing virsh guest domains. The program can be used to
create, pause, and shutdown domains. It can also be used to
list current domains. Libvirt is a C toolkit to interact
with the virtualization capabilities of recent versions of
Linux (and other OSes). It is free software available under
the GNU Lesser General Public License. Virtualization of the
Linux Operating System means the ability to run multiple
instances of Operating Systems concurrently on a single
hardware system where the basic resources are driven by a
Linux instance. The library aims at providing a long term
stable C API. It currently supports Xen, QEmu, KVM, LXC,
OpenVZ, VirtualBox and VMware ESX.</p>

<p>The basic structure of most virsh usage is:</p>

<p>virsh [OPTION]... &lt;command&gt; &lt;domain-id&gt;
[ARG]...</p>

<p>Where command is one of the commands listed below,
domain-id is the numeric domain id, or the domain name
(which will be internally translated to domain id), and ARGS
are command specific options. There are a few exceptions to
this rule in the cases where the command in question acts on
all domains, the entire machine, or directly on the xen
hypervisor. Those exceptions will be clear for each of those
commands.</p>

<p>The virsh program can be used either to run one COMMAND
by giving the command and its arguments on the shell command
line, or a COMMAND_STRING which is a single shell argument
consisting of multiple COMMAND actions and their arguments
joined with whitespace, and separated by semicolons between
commands. Within COMMAND_STRING, virsh understands the same
single, double, and backslash escapes as the shell, although
you must add another layer of shell escaping in creating the
single shell argument. If no command is given in the command
line, virsh will then start a minimal interpreter waiting
for your commands, and the quit command will then exit the
program.</p>

<p>The virsh program understands the following OPTIONS.</p>

<p>-h, --help Ignore all other arguments, and behave as if
the help command were given instead.</p>

<p>-v, --version[=short] Ignore all other arguments, and
prints the version of the libvirt library virsh is coming
from</p>

<p>-V, --version=long Ignore all other arguments, and
prints the version of the libvirt library virsh is coming
from and which options and driver are compiled in.</p>

<p>-c, --connect URI Connect to the specified URI, as if by
the connect command, instead of the default connection.</p>

<p>-d, --debug LEVEL Enable debug messages at integer LEVEL
and above. LEVEL can range from 0 (default) to 4.</p>

<p>-l, --log FILE Output logging details to FILE.</p>

<p>-q, --quiet Avoid extra informational messages.</p>

<p>-r, --readonly Make the initial connection read-only, as
if by the --readonly option of the connect command.</p>

<p>-t, --timing Output elapsed time information for each
command.</p>

<p>NOTES Most virsh operations rely upon the libvirt
library being able to connect to an already running libvirtd
service. This can usually be done using the command service
libvirtd start.</p>

<p>Most virsh commands require root privileges to run due
to the communications channels used to talk to the
hypervisor. Running as non root will return an error.</p>

<p>Most virsh commands act synchronously, except maybe
shutdown, setvcpus and setmem. In those cases the fact that
the virsh program returned, may not mean the action is
complete and you must poll periodically to detect that the
guest completed the operation.</p>

<p>GENERIC COMMANDS The following commands are generic i.e.
not specific to a domain.</p>

<p>help [command-or-group] This lists each of the virsh
commands. When used without options, all commands are
listed, one per line, grouped into related categories,
displaying the keyword for each group.</p>

<p>To display only commands for a specific group, give the
keyword for that group as an option. For example:</p>

<p>virsh # help host</p>

<p>Host and Hypervisor (help keyword &rsquo;host&rsquo;):
capabilities capabilities connect (re)connect to hypervisor
freecell NUMA free memory hostname print the hypervisor
hostname qemu-attach Attach to existing QEMU process
qemu-monitor-command QEMU Monitor Command sysinfo print the
hypervisor sysinfo uri print the hypervisor canonical
URI</p>

<p>To display detailed information for a specific command,
give its name as the option instead. For example:</p>

<p>virsh # help list NAME list - list domains</p>

<p>SYNOPSIS list [--inactive] [--all]</p>

<p>DESCRIPTION Returns list of domains.</p>

<p>OPTIONS --inactive list inactive domains --all list
inactive &amp; active domains</p>

<p>quit, exit quit this interactive terminal</p>

<p>version Will print out the major version info about what
this built from.</p>

<p>Example</p>

<p>virsh version</p>

<p>Compiled against library: libvir 0.0.6</p>

<p>Using library: libvir 0.0.6</p>

<p>Using API: Xen 3.0.0</p>

<p>Running hypervisor: Xen 3.0.0</p>

<p>cd [directory] Will change current directory to
directory. The default directory for the cd command is the
home directory or, if there is no HOME variable in the
environment, the root directory.</p>

<p>This command is only available in interactive mode.</p>

<p>pwd Will print the current directory.</p>

<p>connect URI [--readonly] (Re)-Connect to the hypervisor.
When the shell is first started, this is automatically run
with the URI parameter requested by the &quot;-c&quot;
option on the command line. The URI parameter specifies how
to connect to the hypervisor. The documentation page at
&lt;http://libvirt.org/uri.html&gt; list the values
supported, but the most common are:</p>

<p>xen:/// this is used to connect to the local Xen
hypervisor, this is the default</p>

<p>qemu:///system connect locally as root to the daemon
supervising QEmu and KVM domains</p>

<p>qemu:///session connect locally as a normal user to his
own set of QEmu and KVM domains</p>

<p>lxc:/// connect to a local linux container</p>

<p>For remote access see the documentation page on how to
make URIs. The --readonly option allows for read-only
connection</p>

<p>uri Prints the hypervisor canonical URI, can be useful
in shell mode.</p>

<p>hostname Print the hypervisor hostname.</p>

<p>sysinfo Print the XML representation of the hypervisor
sysinfo, if available.</p>

<p>nodeinfo Returns basic information about the node, like
number and type of CPU, and size of the physical memory. The
output corresponds to virNodeInfo structure. Specifically,
the &quot;CPU socket(s)&quot; field means number of CPU
sockets per NUMA cell.</p>

<p>nodecpustats [cpu] [--percent] Returns cpu stats of the
node. If cpu is specified, this will prints specified cpu
statistics only. If --percent is specified, this will prints
percentage of each kind of cpu statistics during 1
second.</p>

<p>nodememstats [cell] Returns memory stats of the node. If
cell is specified, this will prints specified cell
statistics only.</p>

<p>capabilities Print an XML document describing the
capabilities of the hypervisor we are currently connected
to. This includes a section on the host capabilities in
terms of CPU and features, and a set of description for each
kind of guest which can be virtualized. For a more complete
description see: &lt;http://libvirt.org/formatcaps.html&gt;
The XML also show the NUMA topology information if
available.</p>

<p>inject-nmi domain-id Inject NMI to the guest.</p>

<p>list [--inactive | --all] [--managed-save] Prints
information about existing domains. If no options are
specified it prints out information about running
domains.</p>

<p>An example format for the list is as follows:</p>

<p>virsh list Id Name State</p>

<p>----------------------------------</p>

<p>0 Domain-0 running 2 fedora paused</p>

<p>Name is the name of the domain. ID the domain numeric
id. State is the run state (see below).</p>

<p>STATES</p>

<p>The State field lists 7 states for a domain, and which
ones the current domain is in.</p>

<p>running The domain is currently running on a CPU</p>

<p>idle The domain is idle, and not running or runnable.
This can be caused because the domain is waiting on IO (a
traditional wait state) or has gone to sleep because there
was nothing else for it to do.</p>

<p>paused The domain has been paused, usually occurring
through the administrator running virsh suspend. When in a
paused state the domain will still consume allocated
resources like memory, but will not be eligible for
scheduling by the hypervisor.</p>

<p>send-key domain-id [--codeset codeset] [--holdtime
holdtime] keycode... Parse the keycode sequence as
keystrokes to send to domain-id. Each keycode can either be
a numeric value or a symbolic name from the corresponding
codeset. If --holdtime is given, each keystroke will be held
for that many milliseconds. The default codeset is linux,
but use of the --codeset option allows other codesets to be
chosen.</p>

<p>linux The numeric values are those defined by the Linux
generic input event subsystem. The symbolic names match the
corresponding Linux key constant macro names.</p>

<p>xt The numeric values are those defined by the original
XT keyboard controller. No symbolic names are provided</p>

<p>atset1 The numeric values are those defined by the AT
keyboard controller, set 1 (aka XT compatible set). Extended
keycoes from atset1 may differ from extended keycodes in the
xt codeset. No symbolic names are provided</p>

<p>atset2 The numeric values are those defined by the AT
keyboard controller, set 2. No symbolic names are
provided</p>

<p>atset3 The numeric values are those defined by the AT
keyboard controller, set 3 (aka PS/2 compatible set). No
symbolic names are provided</p>

<p>os_x The numeric values are those defined by the OS-X
keyboard input subsystem. The symbolic names match the
corresponding OS-X key constant macro names</p>

<p>xt_kbd The numeric values are those defined by the Linux
KBD device. These are a variant on the original XT codeset,
but often with different encoding for extended keycodes. No
symbolic names are provided.</p>

<p>win32 The numeric values are those defined by the Win32
keyboard input subsystem. The symbolic names match the
corresponding Win32 key constant macro names</p>

<p>usb The numeric values are those defined by the USB HID
specification for keyboard input. No symbolic names are
provided</p>

<p>rfb The numeric values are those defined by the RFB
extension for sending raw keycodes. These are a variant on
the XT codeset, but extended keycodes have the low bit of
the second byte set, instead of the high bit of the first
byte. No symbolic names are provided.</p>

<p>Examples # send three strokes k, e, y, using xt codeset
virsh send-key dom --codeset xt 37 18 21 # send one stroke
right-ctrl+C virsh send-key dom KEY_RIGHTCTRL KEY_C # send a
tab, held for 1 second virsh send-key --holdtime 1000
0xf</p>

<p>shutdown The domain is in the process of shutting down,
i.e. the guest operating system has been notified and should
be in the process of stopping its operations gracefully.</p>

<p>shut off The domain is not running. Usually this
indicates the domain has been shut down completely, or has
not been started.</p>

<p>crashed The domain has crashed, which is always a
violent ending. Usually this state can only occur if the
domain has been configured not to restart on crash.</p>

<p>dying The domain is in process of dying, but hasnt
completely shutdown or crashed.</p>

<p>If --managed-save is specified, then domains that have
managed save state (only possible if they are in the shut
off state) will instead show as saved in the listing.</p>

<p>freecell [cellno | --all] Prints the available amount of
memory on the machine or within a NUMA cell if cellno is
provided. If --all is provided instead of --cellno, then
show the information on all NUMA cells.</p>

<p>cpu-baseline FILE Compute baseline CPU which will be
supported by all host CPUs given in &lt;file&gt;. The list
of host CPUs is built by extracting all &lt;cpu&gt; elements
from the &lt;file&gt;. Thus, the &lt;file&gt; can contain
either a set of &lt;cpu&gt; elements separated by new lines
or even a set of complete &lt;capabilities&gt; elements
printed by capabilities command.</p>

<p>cpu-compare FILE Compare CPU definition from XML
&lt;file&gt; with host CPU. The XML &lt;file&gt; may contain
either host or guest CPU definition. The host CPU definition
is the &lt;cpu&gt; element and its contents as printed by
capabilities command. The guest CPU definition is the
&lt;cpu&gt; element and its contents from domain XML
definition. For more information on guest CPU definition
see:
&lt;http://libvirt.org/formatdomain.html#elementsCPU&gt;</p>

<p>DOMAIN COMMANDS The following commands manipulate
domains directly, as stated previously most commands take
domain-id as the first parameter. The domain-id can be
specified as a short integer, a name or a full UUID.</p>

<p>autostart [--disable] domain-id Configure a domain to be
automatically started at boot.</p>

<p>The option --disable disables autostarting.</p>

<p>console domain-id [devname] Connect the virtual serial
console for the guest. The optional devname parameter refers
to the device alias of an alternate console, serial or
parallel device configured for the guest. If omitted, the
primary console will be opened.</p>

<p>create FILE [--console] [--paused] [--autodestroy]
Create a domain from an XML &lt;file&gt;. An easy way to
create the XML &lt;file&gt; is to use the dumpxml command to
obtain the definition of a pre-existing guest. The domain
will be paused if the --paused option is used and supported
by the driver; otherwise it will be running. If --console is
requested, attach to the console after creation. If
--autodestroy is requested, then the guest will be
automatically destroyed when virsh closes its connection to
libvirt, or otherwise exits.</p>

<p>Example</p>

<p>virsh dumpxml &lt;domain-id&gt; &gt; domain.xml vi
domain.xml (or make changes with your other text editor)
virsh create &lt; domain.xml</p>

<p>define FILE Define a domain from an XML &lt;file&gt;.
The domain definition is registered but not started.</p>

<p>destroy domain-id Immediately terminate the domain
domain-id. This doesnt give the domain OS any chance to
react, and its the equivalent of ripping the power cord out
on a physical machine. In most cases you will want to use
the shutdown command instead. However, this does not delete
any storage volumes used by the guest, and if the domain is
persistent, it can be restarted later.</p>

<p>If domain-id is transient, then the metadata of any
snapshots will be lost once the guest stops running, but the
snapshot contents still exist, and a new domain with the
same name and UUID can restore the snapshot metadata with
snapshot-create.</p>

<p>domblkstat domain block-device Get device block stats
for a running domain. A block-device corresponds to a unique
target name (&lt;target dev= name /&gt;) or source file
(&lt;source file=name/&gt;) for one of the disk devices
attached to domain (see also domblklist for listing these
names).</p>

<p>domifstat domain interface-device Get network interface
stats for a running domain.</p>

<p>dommemstat domain Get memory stats for a running
domain.</p>

<p>domblkinfo domain block-device Get block device size
info for a domain. A block-device corresponds to a unique
target name (&lt;target dev= name /&gt;) or source file
(&lt;source file=name/&gt;) for one of the disk devices
attached to domain (see also domblklist for listing these
names).</p>

<p>domblklist domain [--inactive] Print a table showing the
names of all block devices associated with domain, as well
as the path to the source of each device. If --inactive is
specified, query the block devices that will be used on the
next boot, rather than those currently in use by a running
domain. Other contexts that require a block device name
(such as domblkinfo or snapshot-create for disk snapshots)
will accept either target or unique source names printed by
this command.</p>

<p>blockpull domain path [bandwidth] Populate a disk from
its backing image. Once all data from its backing image has
been pulled, the disk no longer depends on the backing
image. It pulls data for the entire disk in the background,
the process of the operation can be checked with
blockjob.</p>

<p>path specifies fully-qualified path of the disk.
bandwidth specifies copying bandwidth limit in Mbps.</p>

<p>blockjob domain path [--abort] [--info] [bandwidth]
Manage active block operations.</p>

<p>path specifies fully-qualified path of the disk. If
--abort is specified, the active job on the specified disk
will be aborted. If --info is specified, the active job
information on the specified disk will be printed. bandwidth
can be used to set bandwidth limit for the active job.</p>

<p>dominfo domain-id Returns basic information about the
domain.</p>

<p>domuuid domain-name-or-id Convert a domain name or id to
domain UUID</p>

<p>domid domain-name-or-uuid Convert a domain name (or
UUID) to a domain id</p>

<p>domjobabort domain-id-or-uuid Abort the currently
running domain job.</p>

<p>domjobinfo domain-id-or-uuid Returns information about
jobs running on a domain.</p>

<p>domname domain-id-or-uuid Convert a domain Id (or UUID)
to domain name</p>

<p>domstate domain-id [--reason] Returns state about a
domain. --reason tells virsh to also print reason for the
state.</p>

<p>domcontrol domain-id Returns state of an interface to
VMM used to control a domain. For states other than
&quot;ok&quot; or &quot;error&quot; the command also prints
number of seconds elapsed since the control interface
entered its current state.</p>

<p>domxml-from-native format config Convert the file config
in the native guest configuration format named by format to
a domain XML format.</p>

<p>domxml-to-native format xml Convert the file xml in
domain XML format to the native guest configuration format
named by format.</p>

<p>dump domain-id corefilepath [--bypass-cache] { [--live]
| [--crash] | [--reset] } Dumps the core of a domain to a
file for analysis. If --live is specified, the domain
continues to run until the core dump is complete, rather
than pausing up front. If --crash is specified, the domain
is halted with a crashed status, rather than merely left in
a paused state. If --reset is specified, the domain is reset
after successful dump. Note, these three switches are
mutually exclusive. If --bypass-cache is specified, the save
will avoid the file system cache, although this may slow
down the operation.</p>

<p>The progress may be monitored using domjobinfo virsh
command and canceled with domjobabort command (sent by
another virsh instance). Interrupting (usually with
&quot;Ctrl-C&quot;) the virsh process which runs dump
command is not enough to actually cancel the operation.</p>

<p>NOTE: Some hypervisors may require the user to manually
ensure proper permissions on file and path specified by
argument corefilepath.</p>

<p>dumpxml domain-id [--inactive] [--security-info]
[--update-cpu] Output the domain information as an XML dump
to stdout, this format can be used by the create command.
Additional options affecting the XML dump may be used.
--inactive tells virsh to dump domain configuration that
will be used on next start of the domain as opposed to the
current domain configuration. Using --security-info will
also include security sensitive information in the XML dump.
--update-cpu updates domain CPU requirements according to
host CPU.</p>

<p>echo [--shell] [--xml] [arg...] Echo back each arg,
separated by space. If --shell is specified, then the output
will be single-quoted where needed, so that it is suitable
for reuse in a shell context. If --xml is specified, then
the output will be escaped for use in XML.</p>

<p>edit domain-id Edit the XML configuration file for a
domain.</p>

<p>This is equivalent to:</p>

<p>virsh dumpxml domain &gt; domain.xml vi domain.xml (or
make changes with your other text editor) virsh define
domain.xml</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>managedsave domain-id [--bypass-cache] [{--running |
--paused}] Save and destroy (stop) a running domain, so it
can be restarted from the same state at a later time. When
the virsh start command is next run for the domain, it will
automatically be started from this saved state. If
--bypass-cache is specified, the save will avoid the file
system cache, although this may slow down the operation.</p>

<p>The progress may be monitored using domjobinfo virsh
command and canceled with domjobabort command (sent by
another virsh instance). Interrupting (usually with
&quot;Ctrl-C&quot;) the virsh process which runs managedsave
command is not enough to actually cancel the operation.</p>

<p>Normally, starting a managed save will decide between
running or paused based on the state the domain was in when
the save was done; passing either the --running or --paused
flag will allow overriding which state the start should
use.</p>

<p>The dominfo command can be used to query whether a
domain currently has any managed save image.</p>

<p>managedsave-remove domain-id Remove the managedsave
state file for a domain, if it exists. This ensures the
domain will do a full boot the next time it is started.</p>

<p>maxvcpus [type] Provide the maximum number of virtual
CPUs supported for a guest VM on this connection. If
provided, the type parameter must be a valid type attribute
for the &lt;domain&gt; element of XML.</p>

<p>migrate [--live] [--direct] [--p2p [--tunnelled]]
[--persistent] [--undefinesource] [--suspend]
[--copy-storage-all] [--copy-storage-inc]
[--change-protection] [--verbose] domain-id desturi
[migrateuri] [dname] [--timeout seconds] [--xml file]
Migrate domain to another host. Add --live for live
migration; --p2p for peer-2-peer migration; --direct for
direct migration; or --tunnelled for tunnelled migration.
--persistent leaves the domain persistent on destination
host, --undefinesource undefines the domain on the source
host, and --suspend leaves the domain paused on the
destination host. --copy-storage-all indicates migration
with non-shared storage with full disk copy,
--copy-storage-inc indicates migration with non-shared
storage with incremental copy (same base image shared
between source and destination). In both cases the disk
images have to exist on destination host, the
--copy-storage-... options only tell libvirt to transfer
data from the images on source host to the images found at
the same place on the destination host. --change-protection
enforces that no incompatible configuration changes will be
made to the domain while the migration is underway; this
flag is implicitly enabled when supported by the hypervisor,
but can be explicitly used to reject the migration if the
hypervisor lacks change protection support. --verbose
displays the progress of migration.</p>

<p>The desturi is the connection URI of the destination
host, and migrateuri is the migration URI, which usually can
be omitted. dname is used for renaming the domain to new
name during migration, which also usually can be omitted.
Likewise, --xml file is usually omitted, but can be used to
supply an alternative XML file for use on the destination to
supply a larger set of changes to any host- specific
portions of the domain XML, such as accounting for naming
differences between source and destination in accessing
underlying storage.</p>

<p>--timeout seconds forces guest to suspend when live
migration exceeds that many seconds, and then the migration
will complete offline. It can only be used with --live.</p>

<p>Running migration can be canceled by interrupting virsh
(usually using &quot;Ctrl-C&quot;) or by domjobabort command
sent from another virsh instance.</p>

<p>Note: The desturi parameter for normal migration and
peer2peer migration has different semantics:</p>

<p>&middot; normal migration: the desturi is an address of
the target host as seen from the client machine.</p>

<p>&middot; peer2peer migration: the desturi is an address
of the target host as seen from the source machine.</p>

<p>migrate-setmaxdowntime domain-id downtime Set maximum
tolerable downtime for a domain which is being live-
migrated to another host. The downtime is a number of
milliseconds the guest is allowed to be down at the end of
live migration.</p>

<p>migrate-setspeed domain-id bandwidth Set the maximum
migration bandwidth (in Mbps) for a domain which is being
migrated to another host.</p>

<p>reboot domain-id Reboot a domain. This acts just as if
the domain had the reboot command run from the console. The
command returns as soon as it has executed the reboot
action, which may be significantly before the domain
actually reboots.</p>

<p>The exact behavior of a domain when it reboots is set by
the on_reboot parameter in the domains XML definition.</p>

<p>restore state-file [--bypass-cache] [--xml file]
[{--running | --paused}] Restores a domain from a virsh save
state file. See save for more info.</p>

<p>If --bypass-cache is specified, the restore will avoid
the file system cache, although this may slow down the
operation.</p>

<p>--xml file is usually omitted, but can be used to supply
an alternative XML file for use on the restored guest with
changes only in the host-specific portions of the domain
XML. For example, it can be used to account for file naming
differences in underlying storage due to disk snapshots
taken after the guest was saved.</p>

<p>Normally, restoring a saved image will use the state
recorded in the save image to decide between running or
paused; passing either the --running or --paused flag will
allow overriding which state the domain should be started
in.</p>

<p>Note: To avoid corrupting file system contents within
the domain, you should not reuse the saved state file for a
second restore unless you have also reverted all storage
volumes back to the same contents as when the state file was
created.</p>

<p>save domain-id state-file [--bypass-cache] [--xml file]
[{--running | --paused}] Saves a running domain (RAM, but
not disk state) to a state file so that it can be restored
later. Once saved, the domain will no longer be running on
the system, thus the memory allocated for the domain will be
free for other domains to use. virsh restore restores from
this state file. If --bypass-cache is specified, the save
will avoid the file system cache, although this may slow
down the operation.</p>

<p>The progress may be monitored using domjobinfo virsh
command and canceled with domjobabort command (sent by
another virsh instance). Interrupting (usually with
&quot;Ctrl-C&quot;) the virsh process which runs save
command is not enough to actually cancel the operation.</p>

<p>This is roughly equivalent to doing a hibernate on a
running computer, with all the same limitations. Open
network connections may be severed upon restore, as TCP
timeouts may have expired.</p>

<p>--xml file is usually omitted, but can be used to supply
an alternative XML file for use on the restored guest with
changes only in the host-specific portions of the domain
XML. For example, it can be used to account for file naming
differences that are planned to be made via disk snapshots
of underlying storage after the guest is saved.</p>

<p>Normally, restoring a saved image will decide between
running or paused based on the state the domain was in when
the save was done; passing either the --running or --paused
flag will allow overriding which state the restore should
use.</p>

<p>Domain saved state files assume that disk images will be
unchanged between the creation and restore point. For a more
complete system restore point, where the disk state is saved
alongside the memory state, see the snapshot family of
commands.</p>

<p>save-image-define file xml [{--running | --paused}]
Update the domain XML that will be used when file is later
used in the restore command. The xml argument must be a file
name containing the alternative XML, with changes only in
the host- specific portions of the domain XML. For example,
it can be used to account for file naming differences
resulting from creating disk snapshots of underlying storage
after the guest was saved.</p>

<p>The save image records whether the domain should be
restored to a running or paused state. Normally, this
command does not alter the recorded state; passing either
the --running or --paused flag will allow overriding which
state the restore should use.</p>

<p>save-image-dumpxml file [--security-info] Extract the
domain XML that was in effect at the time the saved state
file file was created with the save command. Using
--security-info will also include security sensitive
information.</p>

<p>save-image-edit file [{--running | --paused}] Edit the
XML configuration associated with a saved state file file
created by the save command.</p>

<p>The save image records whether the domain should be
restored to a running or paused state. Normally, this
command does not alter the recorded state; passing either
the --running or --paused flag will allow overriding which
state the restore should use.</p>

<p>This is equivalent to:</p>

<p>virsh save-image-dumpxml state-file &gt; state-file.xml
vi state-file.xml (or make changes with your other text
editor) virsh save-image-define state-file
state-file-xml</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>schedinfo [--set parameter=value] domain-id [[--config]
[--live] | [--current]] schedinfo [--weight number] [--cap
number] domain-id Allows you to show (and set) the domain
scheduler parameters. The parameters available for each
hypervisor are:</p>

<p>LXC (posix scheduler) : cpu_shares</p>

<p>QEMU/KVM (posix scheduler): cpu_shares, vcpu_period,
vcpu_quota</p>

<p>Xen (credit scheduler): weight, cap</p>

<p>ESX (allocation scheduler): reservation, limit,
shares</p>

<p>If --live is specified, set scheduler information of a
running guest. If --config is specified, affect the next
boot of a persistent guest. If --current is specified,
affect the current guest state.</p>

<p>Note: The cpu_shares parameter has a valid value range
of 0-262144; Negative values are wrapped to positive, and
larger values are capped at the maximum. Therefore, -1 is a
useful shorthand for 262144. On the Linux kernel, the values
0 and 1 are automatically converted to a minimal value of
2.</p>

<p>Note: The weight and cap parameters are defined only for
the XEN_CREDIT scheduler and are now DEPRECATED.</p>

<p>Note: The vcpu_period parameter has a valid value range
of 1000-1000000 or 0, and the vcpu_quota parameter has a
valid value range of 1000-18446744073709551 or less than 0.
The value 0 for either parameter is the same as not
specifying that parameter.</p>

<p>screenshot domain-id [imagefilepath] [--screen screenID]
Takes a screenshot of a current domain console and stores it
into a file. Optionally, if hypervisor supports more
displays for a domain, screenID allows to specify which
screen will be captured. It is the sequential number of
screen. In case of multiple graphics cards, heads are
enumerated before devices, e.g. having two graphics cards,
both with four heads, screen ID 5 addresses the second head
on the second card.</p>

<p>setmem domain-id kilobytes [[--config] [--live] |
[--current]] Change the memory allocation for a guest
domain. If --live is specified, perform a memory balloon of
a running guest. If --config is specified, affect the next
boot of a persistent guest. If --current is specified,
affect the current guest state. Both --live and --config
flags may be given, but --current is exclusive. If no flag
is specified, behavior is different depending on
hypervisor.</p>

<p>Some hypervisors require a larger granularity than
kilobytes, and requests that are not an even multiple will
be rounded up. For example, vSphere/ESX rounds the parameter
up unless the kB argument is evenly divisible by 1024 (that
is, the kB argument happens to represent megabytes).</p>

<p>For Xen, you can only adjust the memory of a running
domain if the domain is paravirtualized or running the PV
balloon driver.</p>

<p>setmaxmem domain-id kilobytes [[--config] [--live] |
[--current]] Change the maximum memory allocation limit for
a guest domain. If --live is specified, affect a running
guest. If --config is specified, affect the next boot of a
persistent guest. If --current is specified, affect the
current guest state. Both --live and --current flags may be
given, but --current is exclusive. If no flag is specified,
behavior is different depending on hypervisor.</p>

<p>This command works for at least the Xen, QEMU/KVM and
vSphere/ESX hypervisors.</p>

<p>Some hypervisors require a larger granularity than
kilobytes, rounding up requests that are not an even
multiple of the desired amount. vSphere/ESX is one of these,
requiring the parameter to be evenly divisible by 4MB. For
vSphere/ESX, 263168 (257MB) would be rounded up because its
not a multiple of 4MB, while 266240 (260MB) is valid without
rounding.</p>

<p>memtune domain-id [--hard-limit kilobytes] [--soft-limit
kilobytes] [--swap-hard-limit kilobytes] [--min-guarantee
kilobytes] [[--config] [--live] | [--current]] Allows you to
display or set the domain memory parameters. Without flags,
the current settings are displayed; with a flag, the
appropriate limit is adjusted if supported by the
hypervisor. LXC and QEMU/KVM support --hard-limit,
--soft-limit, and --swap-hard-limit.</p>

<p>If --live is specified, affect a running guest. If
--config is specified, affect the next boot of a persistent
guest. If --current is specified, affect the current guest
state. Both --live and --current flags may be given, but
--current is exclusive. If no flag is specified, behavior is
different depending on hypervisor.</p>

<p>For QEMU/KVM, the parameters are applied to the QEMU
process as a whole. Thus, when counting them, one needs to
add up guest RAM, guest video RAM, and some memory overhead
of QEMU itself. The last piece is hard to determine so one
needs guess and try.</p>

<p>--hard-limit The maximum memory the guest can use. The
units for this value are kilobytes (i.e. blocks of 1024
bytes).</p>

<p>--soft-limit The memory limit to enforce during memory
contention. The units for this value are kilobytes (i.e.
blocks of 1024 bytes).</p>

<p>--swap-hard-limit The maximum memory plus swap the guest
can use. The units for this value are kilobytes (i.e. blocks
of 1024 bytes). This has to be more than hard-limit value
provided.</p>

<p>--min-guarantee The guaranteed minimum memory allocation
for the guest. The units for this value are kilobytes (i.e.
blocks of 1024 bytes).</p>

<p>blkiotune domain-id [--weight weight] [[--config]
[--live] | [--current]] Display or set the blkio parameters.
QEMU/KVM supports --weight. --weight is in range [100,
1000].</p>

<p>If --live is specified, affect a running guest. If
--config is specified, affect the next boot of a persistent
guest. If --current is specified, affect the current guest
state. Both --live and --current flags may be given, but
--current is exclusive. If no flag is specified, behavior is
different depending on hypervisor.</p>

<p>setvcpus domain-id count [--maximum] [[--config]
[--live] | [--current]] Change the number of virtual CPUs
active in a guest domain. By default, this command works on
active guest domains. To change the settings for an inactive
guest domain, use the --config flag.</p>

<p>The count value may be limited by host, hypervisor, or a
limit coming from the original description of the guest
domain. For Xen, you can only adjust the virtual CPUs of a
running domain if the domain is paravirtualized.</p>

<p>If the --config flag is specified, the change is made to
the stored XML configuration for the guest domain, and will
only take effect when the guest domain is next started.</p>

<p>If --live is specified, the guest domain must be active,
and the change takes place immediately. Both the --config
and --live flags may be specified together if supported by
the hypervisor.</p>

<p>If --current is specified, affect the current guest
state.</p>

<p>When no flags are given, the --live flag is assumed and
the guest domain must be active. In this situation it is up
to the hypervisor whether the --config flag is also assumed,
and therefore whether the XML configuration is adjusted to
make the change persistent.</p>

<p>The --maximum flag controls the maximum number of
virtual cpus that can be hot-plugged the next time the
domain is booted. As such, it must only be used with the
--config flag, and not with the --live flag.</p>

<p>shutdown domain-id Gracefully shuts down a domain. This
coordinates with the domain OS to perform graceful shutdown,
so there is no guarantee that it will succeed, and may take
a variable length of time depending on what services must be
shutdown in the domain.</p>

<p>The exact behavior of a domain when it shuts down is set
by the on_shutdown parameter in the domains XML
definition.</p>

<p>If domain-id is transient, then the metadata of any
snapshots will be lost once the guest stops running, but the
snapshot contents still exist, and a new domain with the
same name and UUID can restore the snapshot metadata with
snapshot-create.</p>

<p>start domain-name [--console] [--paused] [--autodestroy]
[--bypass-cache] [--force-boot] Start a (previously defined)
inactive domain, either from the last managedsave state, or
via a fresh boot if no managedsave state is present. The
domain will be paused if the --paused option is used and
supported by the driver; otherwise it will be running. If
--console is requested, attach to the console after
creation. If --autodestroy is requested, then the guest will
be automatically destroyed when virsh closes its connection
to libvirt, or otherwise exits. If --bypass-cache is
specified, and managedsave state exists, the restore will
avoid the file system cache, although this may slow down the
operation. If --force-boot is specified, then any
managedsave state is discarded and a fresh boot occurs.</p>

<p>suspend domain-id Suspend a running domain. It is kept
in memory but won t be scheduled anymore.</p>

<p>resume domain-id Moves a domain out of the suspended
state. This will allow a previously suspended domain to now
be eligible for scheduling by the underlying hypervisor.</p>

<p>ttyconsole domain-id Output the device used for the TTY
console of the domain. If the information is not available
the processes will provide an exit code of 1.</p>

<p>undefine domain-id [--managed-save]
[--snapshots-metadata] Undefine a domain. If the domain is
running, this converts it to a transient domain, without
stopping it. If the domain is inactive, the domain
configuration is removed.</p>

<p>The --managed-save flag guarantees that any managed save
image (see the managedsave command) is also cleaned up.
Without the flag, attempts to undefine a domain with a
managed save image will fail.</p>

<p>The --snapshots-metadata flag guarantees that any
snapshots (see the snapshot-list command) are also cleaned
up when undefining an inactive domain. Without the flag,
attempts to undefine an inactive domain with snapshot
metadata will fail. If the domain is active, this flag is
ignored.</p>

<p>NOTE: For an inactive domain, the domain name or UUID
must be used as the domain-id.</p>

<p>vcpucount domain-id [{--maximum | --active} {--config |
--live | --current}] Print information about the virtual cpu
counts of the given domain- id. If no flags are specified,
all possible counts are listed in a table; otherwise, the
output is limited to just the numeric value requested. For
historical reasons, the table lists the label
&quot;current&quot; on the rows that can be queried in
isolation via the --active flag, rather than relating to the
--current flag.</p>

<p>--maximum requests information on the maximum cap of
vcpus that a domain can add via setvcpus, while --active
shows the current usage; these two flags cannot both be
specified. --config requires a persistent domain and
requests information regarding the next time the domain will
be booted, --live requires a running domain and lists
current values, and --current queries according to the
current state of the domain (corresponding to --live if
running, or --config if inactive); these three flags are
mutually exclusive. Thus, this command always takes exactly
zero or two flags.</p>

<p>vcpuinfo domain-id Returns basic information about the
domain virtual CPUs, like the number of vCPUs, the running
time, the affinity to physical processors.</p>

<p>vcpupin domain-id [vcpu] [cpulist] [[--live] [--config]
| [--current]] Query or change the pinning of domain VCPUs
to host physical CPUs. To pin a single vcpu, specify
cpulist; otherwise, you can query one vcpu or omit vcpu to
list all at once.</p>

<p>cpulist is a list of physical CPU numbers. Its syntax is
a comma separated list and a special markup using - and ^
(ex. 0-4, 0-3,^2 ) can also be allowed. The - denotes the
range and the ^ denotes exclusive. If you want to reset
vcpupin setting, that is, to pin vcpu all physical cpus,
simply specify r as a cpulist. If --live is specified,
affect a running guest. If --config is specified, affect the
next boot of a persistent guest. If --current is specified,
affect the current guest state. Both --live and --config
flags may be given if cpulist is present, but --current is
exclusive. If no flag is specified, behavior is different
depending on hypervisor.</p>

<p>Note: The expression is sequentially evaluated, so
&quot;0-15,^8&quot; is identical to &quot;9-14,0-7,15&quot;
but not identical to &quot;^8,0-15&quot;.</p>

<p>vncdisplay domain-id Output the IP address and port
number for the VNC display. If the information is not
available the processes will provide an exit code of 1.</p>

<p>DEVICE COMMANDS The following commands manipulate
devices associated to domains. The domain-id can be
specified as a short integer, a name or a full UUID. To
better understand the values allowed as options for the
command reading the documentation at
&lt;http://libvirt.org/formatdomain.html&gt; on the format
of the device sections to get the most accurate set of
accepted values.</p>

<p>attach-device domain-id FILE Attach a device to the
domain, using a device definition in an XML file. See the
documentation to learn about libvirt XML format for a
device. For cdrom and floppy devices, this command only
replaces the media within the single existing device;
consider using update- device for this usage. For
passthrough host devices, see also nodedev-dettach, needed
if the device does not use managed mode.</p>

<p>attach-disk domain-id source target [--driver driver]
[--subdriver subdriver] [--cache cache] [--type type]
[--mode mode] [--persistent] [--sourcetype soucetype]
[--serial serial] [--shareable] [--address address] Attach a
new disk device to the domain. source and target are paths
for the files and devices. driver can be file, tap or phy
for the Xen hypervisor depending on the kind of access; or
qemu for the QEMU emulator. type can indicate cdrom or
floppy as alternative to the disk default, although this use
only replaces the media within the existing virtual cdrom or
floppy device; consider using update-device for this usage
instead. mode can specify the two specific mode readonly or
shareable. persistent indicates the changes will affect the
next boot of the domain. sourcetype can indicate the type of
source (block|file) cache can be one of &quot;default&quot;,
&quot;none&quot;, &quot;writethrough&quot; or
&quot;writeback&quot;. serial is the serial of disk device.
shareable indicates the disk device is shareable between
domains. address is the address of disk device in the form
of pci:domain.bus.slot.function, scsi:controller.bus.unit or
ide:controller.bus.unit.</p>

<p>attach-interface domain-id type source [--target target]
[--mac mac] [--script script] [--model model] [--persistent]
Attach a new network interface to the domain. type can be
either network to indicate a physical network device or
bridge to indicate a bridge to a device. source indicates
the source device. target allows to indicate the target
device in the guest. mac allows to specify the MAC address
of the network interface. script allows to specify a path to
a script handling a bridge instead of the default one. model
allows to specify the model type. persistent indicates the
changes will affect the next boot of the domain.</p>

<p>Note: the optional target value is the name of a device
to be created as the back-end on the node. If not provided a
device named &quot;vnetN&quot; or &quot;vifN&quot; will be
created automatically.</p>

<p>detach-device domain-id FILE Detach a device from the
domain, takes the same kind of XML descriptions as command
attach-device. For passthrough host devices, see also
nodedev-reattach, needed if the device does not use managed
mode.</p>

<p>detach-disk domain-id target Detach a disk device from a
domain. The target is the device as seen from the
domain.</p>

<p>detach-interface domain-id type [--mac mac] Detach a
network interface from a domain. type can be either network
to indicate a physical network device or bridge to indicate
a bridge to a device. It is recommended to use the mac
option to distinguish between the interfaces if more than
one are present on the domain.</p>

<p>update-device domain-id file [--persistent] [--force]
Update the characteristics of a device associated with
domain-id, based on the device definition in an XML file. If
the --persistent option is used, the changes will affect the
next boot of the domain. The --force option can be used to
force device update, e.g., to eject a CD-ROM even if it is
locked/mounted in the domain. See the documentation to learn
about libvirt XML format for a device.</p>

<p>NODEDEV COMMANDS The following commands manipulate host
devices that are intended to be passed through to guest
domains via &lt;hostdev&gt; elements in a domains
&lt;devices&gt; section. A node device key is generally
specified by the bus name followed by its address, using
underscores between all components, such as
pci_0000_00_02_1, usb_1_5_3, or net_eth1_00_27_13_6a_fe_00.
The nodedev-list gives the full list of host devices that
are known to libvirt, although this includes devices that
cannot be assigned to a guest (for example, attempting to
detach the PCI device that controls the hosts hard disk
controller where the guest s disk images live could cause
the host system to lock up or reboot).</p>

<p>For more information on node device definition see:
&lt;http://libvirt.org/formatnode.html&gt;.</p>

<p>Passthrough devices cannot be simultaneously used by the
host and its guest domains, nor by multiple active guests at
once. If the &lt;hostdev&gt; description includes the
attribute managed=ye, and the hypervisor driver supports it,
then the device is in managed mode, and attempts to use that
passthrough device in an active guest will automatically
behave as if nodedev-dettach (guest start, device hot-plug)
and nodedev-reattach (guest stop, device hot-unplug) were
called at the right points (currently, qemu does this for
PCI devices, but not USB). If a device is not marked as
managed, then it must manually be detached before guests can
use it, and manually reattached to be returned to the host.
Also, if a device is manually detached, then the host does
not regain control of the device without a matching
reattach, even if the guests use the device in managed
mode.</p>

<p>nodedev-create FILE Create a device on the host node
that can then be assigned to virtual machines. Normally,
libvirt is able to automatically determine which host nodes
are available for use, but this allows registration of host
hardware that libvirt did not automatically detect. file
contains xml for a top-level &lt;device&gt; description of a
node device.</p>

<p>nodedev-destroy nodedev Destroy (stop) a device on the
host. Note that this makes libvirt quit managing a host
device, and may even make that device unusable by the rest
of the physical host until a reboot.</p>

<p>nodedev-dettach nodedev Detach nodedev from the host, so
that it can safely be used by guests via &lt;hostdev&gt;
passthrough. This is reversed with nodedev- reattach, and is
done automatically for managed devices.</p>

<p>nodedev-dumpxml nodedev Dump a &lt;device&gt; XML
representation for the given node device, including such
information as the device name, which bus owns the device,
the vendor and product id, and any capabilities of the
device usable by libvirt (such as whether device reset is
supported).</p>

<p>nodedev-list cap --tree List all of the devices
available on the node that are known by libvirt. If cap is
used, the list is filtered to show only the nodes that
include the given capability. If --tree is used, the output
is formatted in a tree representing parents of each
node.</p>

<p>nodedev-reattach nodedev Declare that nodedev is no
longer in use by any guests, and that the host can resume
normal use of the device. This is done automatically for
devices in managed mode, but must be done explicitly to
match any explicit nodedev-dettach.</p>

<p>nodedev-reset nodedev Trigger a device reset for
nodedev, useful prior to transferring a node device between
guest passthrough or the host. Libvirt will often do this
action implicitly when required, but this command allows an
explicit reset when needed.</p>

<p>VIRTUAL NETWORK COMMANDS The following commands
manipulate networks. Libvirt has the capability to define
virtual networks which can then be used by domains and
linked to actual network devices. For more detailed
information about this feature see the documentation at
&lt;http://libvirt.org/formatnetwork.html&gt; . Many of the
commands for virtual networks are similar to the ones used
for domains, but the way to name a virtual network is either
by its name or UUID.</p>

<p>net-autostart network [--disable] Configure a virtual
network to be automatically started at boot. The --disable
option disable autostarting.</p>

<p>net-create file Create a virtual network from an XML
file, see the documentation to get a description of the XML
network format used by libvirt.</p>

<p>net-define file Define a virtual network from an XML
file, the network is just defined but not instantiated.</p>

<p>net-destroy network Destroy (stop) a given virtual
network specified by its name or UUID. This takes effect
immediately.</p>

<p>net-dumpxml network Output the virtual network
information as an XML dump to stdout.</p>

<p>net-edit network Edit the XML configuration file for a
network.</p>

<p>This is equivalent to:</p>

<p>virsh net-dumpxml network &gt; network.xml vi
network.xml (or make changes with your other text editor)
virsh net-define network.xml</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>net-info network Returns basic information about the
network object.</p>

<p>net-list [--inactive | --all] Returns the list of active
networks, if --all is specified this will also include
defined but inactive networks, if --inactive is specified
only the inactive ones will be listed.</p>

<p>net-name network-UUID Convert a network UUID to network
name.</p>

<p>net-start network Start a (previously defined) inactive
network.</p>

<p>net-undefine network Undefine the configuration for an
inactive network.</p>

<p>net-uuid network-name Convert a network name to network
UUID.</p>

<p>INTERFACE COMMANDS The following commands manipulate
host interfaces. Often, these host interfaces can then be
used by name within domain &lt;interface&gt; elements (such
as a system-created bridge interface), but there is no
requirement that host interfaces be tied to any particular
guest configuration XML at all.</p>

<p>Many of the commands for host interfaces are similar to
the ones used for domains, and the way to name an interface
is either by its name or its MAC address. However, using a
MAC address for an iface argument only works when that
address is unique (if an interface and a bridge share the
same MAC address, which is often the case, then using that
MAC address results in an error due to ambiguity, and you
must resort to a name instead).</p>

<p>iface-define file Define a host interface from an XML
file, the interface is just defined but not started.</p>

<p>iface-destroy interface Destroy (stop) a given host
interface, such as by running &quot;if-down&quot; to disable
that interface from active use. This takes effect
immediately.</p>

<p>iface-dumpxml interface [--inactive] Output the host
interface information as an XML dump to stdout. If
--inactive is specified, then the output reflects the
persistent state of the interface that will be used the next
time it is started.</p>

<p>iface-edit interface Edit the XML configuration file for
a host interface.</p>

<p>This is equivalent to:</p>

<p>virsh iface-dumpxml iface &gt; iface.xml vi iface.xml
(or make changes with your other text editor) virsh
iface-define iface.xml</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>iface-list [--inactive | --all] Returns the list of
active host interfaces. If --all is specified this will also
include defined but inactive interfaces. If --inactive is
specified only the inactive ones will be listed.</p>

<p>iface-name interface Convert a host interface MAC to
interface name, if the MAC address is unique among the hosts
interfaces.</p>

<p>interface specifies the interface MAC address.</p>

<p>iface-mac interface Convert a host interface name to MAC
address.</p>

<p>interface specifies the interface name.</p>

<p>iface-start interface Start a (previously defined) host
interface, such as by running &quot;if-up&quot;.</p>

<p>iface-undefine interface Undefine the configuration for
an inactive host interface.</p>

<p>iface-begin Create a snapshot of current host interface
settings, which can later be committed (iface-commit) or
restored (iface-rollback). If a snapshot already exists,
then this command will fail until the previous snapshot has
been committed or restored. Undefined behavior results if
any external changes are made to host interfaces outside of
the libvirt API between the beginning of a snapshot and its
eventual commit or rollback.</p>

<p>iface-commit Declare all changes since the last
iface-begin as working, and delete the rollback point. If no
interface snapshot has already been started, then this
command will fail.</p>

<p>iface-rollback Revert all host interface settings back
to the state recorded in the last iface-begin. If no
interface snapshot has already been started, then this
command will fail. Rebooting the host also serves as an
implicit rollback point.</p>

<p>STORAGE POOL COMMANDS The following commands manipulate
storage pools. Libvirt has the capability to manage various
storage solutions, including files, raw partitions, and
domain-specific formats, used to provide the storage volumes
visible as devices within virtual machines. For more
detailed information about this feature, see the
documentation at
&lt;http://libvirt.org/formatstorage.html&gt; . Many of the
commands for pools are similar to the ones used for
domains.</p>

<p>find-storage-pool-sources type [srcSpec] Returns XML
describing all storage pools of a given type that could be
found. If srcSpec is provided, it is a file that contains
XML to further restrict the query for pools.</p>

<p>find-storage-pool-sources-as type [host] [port]
[initiator] Returns XML describing all storage pools of a
given type that could be found. If host, port, or initiator
are provided, they control where the query is performed.</p>

<p>pool-autostart pool-or-uuid [--disable] Configure
whether pool should automatically start at boot.</p>

<p>pool-build pool-or-uuid Build a given pool.</p>

<p>pool-create file Create and start a pool object from the
XML file.</p>

<p>pool-create-as name --print-xml type [source-host]
[source-path] [source-dev] [source-name] [&lt;target&gt;]
[--source-format format] Create and start a pool object name
from the raw parameters. If --print-xml is specified, then
print the XML of the pool object without creating the pool.
Otherwise, the pool has the specified type.</p>

<p>pool-define file Create, but do not start, a pool object
from the XML file.</p>

<p>pool-define-as name --print-xml type [source-host]
[source-path] [source-dev] [source-name] [&lt;target&gt;]
[--source-format format] Create, but do not start, a pool
object name from the raw parameters. If --print-xml is
specified, then print the XML of the pool object without
defining the pool. Otherwise, the pool has the specified
type.</p>

<p>pool-destroy pool-or-uuid Destroy (stop) a given pool
object. Libvirt will no longer manage the storage described
by the pool object, but the raw data contained in the pool
is not changed, and can be later recovered with
pool-create.</p>

<p>pool-delete pool-or-uuid Destroy the resources used by a
given pool object. This operation is non-recoverable. The
pool object will still exist after this command, ready for
the creation of new storage volumes.</p>

<p>pool-dumpxml pool-or-uuid Returns the XML information
about the pool object.</p>

<p>pool-edit pool-or-uuid Edit the XML configuration file
for a storage pool.</p>

<p>This is equivalent to:</p>

<p>virsh pool-dumpxml pool &gt; pool.xml vi pool.xml (or
make changes with your other text editor) virsh pool-define
pool.xml</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>pool-info pool-or-uuid Returns basic information about
the pool object.</p>

<p>pool-list [--inactive | --all] [--details] List pool
objects known to libvirt. By default, only pools in use by
active domains are listed; --inactive lists just the
inactive pools, and --all lists all pools. The --details
option instructs virsh to additionally display pool
persistence and capacity related information where
available.</p>

<p>pool-name uuid Convert the uuid to a pool name.</p>

<p>pool-refresh pool-or-uuid Refresh the list of volumes
contained in pool.</p>

<p>pool-start pool-or-uuid Start the storage pool, which is
previously defined but inactive.</p>

<p>pool-undefine pool-or-uuid Undefine the configuration
for an inactive pool.</p>

<p>pool-uuid pool Returns the UUID of the named pool.</p>

<p>VOLUME COMMANDS vol-create pool-or-uuid FILE Create a
volume from an XML &lt;file&gt;. pool-or-uuid is the name or
UUID of the storage pool to create the volume in. FILE is
the XML &lt;file&gt; with the volume definition. An easy way
to create the XML &lt;file&gt; is to use the vol-dumpxml
command to obtain the definition of a pre-existing
volume.</p>

<p>Example</p>

<p>virsh vol-dumpxml --pool storagepool1 appvolume1 &gt;
newvolume.xml vi newvolume.xml (or make changes with your
other text editor) virsh vol-create differentstoragepool
newvolume.xml</p>

<p>vol-create-from pool-or-uuid FILE [--inputpool
pool-or-uuid] vol-name- or-key-or-path Create a volume,
using another volume as input. pool-or-uuid is the name or
UUID of the storage pool to create the volume in. FILE is
the XML &lt;file&gt; with the volume definition. --inputpool
pool-or- uuid is the name or uuid of the storage pool the
source volume is in. vol-name-or-key-or-path is the name or
key or path of the source volume.</p>

<p>vol-create-as pool-or-uuid name capacity [--allocation
size] [--format string] [--backing-vol
vol-name-or-key-or-path] [--backing-vol-format string]
Create a volume from a set of arguments. pool-or-uuid is the
name or UUID of the storage pool to create the volume in.
name is the name of the new volume. capacity is the size of
the volume to be created, with optional k, M, G, or T
suffix. --allocation size is the initial size to be
allocated in the volume, with optional k, M, G, or T suffix.
--format string is used in file based storage pools to
specify the volume file format to use; raw, bochs, qcow,
qcow2, vmdk. --backing-vol vol-name-or-key-or-path is the
source backing volume to be used if taking a snapshot of an
existing volume. --backing-vol-format string is the format
of the snapshot backing volume; raw, bochs, qcow, qcow2,
vmdk, host_device.</p>

<p>vol-clone [--pool pool-or-uuid] vol-name-or-key-or-path
name Clone an existing volume. Less powerful, but easier to
type, version of vol-create-from. --pool pool-or-uuid is the
name or UUID of the storage pool to create the volume in.
vol-name-or-key- or-path is the name or key or path of the
source volume. name is the name of the new volume.</p>

<p>vol-delete [--pool pool-or-uuid] vol-name-or-key-or-path
Delete a given volume. --pool pool-or-uuid is the name or
UUID of the storage pool the volume is in.
vol-name-or-key-or-path is the name or key or path of the
volume to delete.</p>

<p>vol-upload [--pool pool-or-uuid] [--offset bytes]
[--length bytes] vol- name-or-key-or-path local-file Upload
the contents of local-file to a storage volume. --pool
pool-or-uuid is the name or UUID of the storage pool the
volume is in. vol-name-or-key-or-path is the name or key or
path of the volume to wipe. --offset is the position in the
storage volume at which to start writing the data. --length
is an upper bound of the amount of data to be uploaded. An
error will occurr if the local- file is greater than the
specified length.</p>

<p>vol-download [--pool pool-or-uuid] [--offset bytes]
[--length bytes] vol-name-or-key-or-path local-file Download
the contents of local-file from a storage volume. --pool
pool-or-uuid is the name or UUID of the storage pool the
volume is in. vol-name-or-key-or-path is the name or key or
path of the volume to wipe. --offset is the position in the
storage volume at which to start reading the data. --length
is an upper bound of the amount of data to be
downloaded.</p>

<p>vol-wipe [--pool pool-or-uuid] vol-name-or-key-or-path
Wipe a volume, ensure data previously on the volume is not
accessible to future reads. --pool pool-or-uuid is the name
or UUID of the storage pool the volume is in.
vol-name-or-key-or-path is the name or key or path of the
volume to wipe.</p>

<p>vol-dumpxml [--pool pool-or-uuid]
vol-name-or-key-or-path Output the volume information as an
XML dump to stdout. --pool pool-or-uuid is the name or UUID
of the storage pool the volume is in.
vol-name-or-key-or-path is the name or key or path of the
volume to output the XML of.</p>

<p>vol-info [--pool pool-or-uuid] vol-name-or-key-or-path
Returns basic information about the given storage volume.
--pool pool-or-uuid is the name or UUID of the storage pool
the volume is in. vol-name-or-key-or-path is the name or key
or path of the volume to return information for.</p>

<p>vol-list [--pool pool-or-uuid] [--details] Return the
list of volumes in the given storage pool. --pool pool-
or-uuid is the name or UUID of the storage pool. The
--details option instructs virsh to additionally display
volume type and capacity related information where
available.</p>

<p>vol-pool [--uuid] vol-key-or-path Return the pool name
or UUID for a given volume. By default, the pool name is
returned. If the --uuid option is given, the pool UUID is
returned instead. vol-key-or-path is the key or path of the
volume to return the pool information for.</p>

<p>vol-path [--pool pool-or-uuid] vol-name-or-key Return
the path for a given volume. --pool pool-or-uuid is the name
or UUID of the storage pool the volume is in.
vol-name-or-key is the name or key of the volume to return
the path for.</p>

<p>vol-name vol-key-or-path Return the name for a given
volume. vol-key-or-path is the key or path of the volume to
return the name for.</p>

<p>vol-key [--pool pool-or-uuid] vol-name-or-path Return
the volume key for a given volume. --pool pool-or-uuid is
the name or UUID of the storage pool the volume is in.
vol-name-or- path is the name or path of the volume to
return the volume key for.</p>

<p>SECRET COMMMANDS The following commands manipulate
&quot;secrets&quot; (e.g. passwords, passphrases and
encryption keys). Libvirt can store secrets independently
from their use, and other objects (e.g. volumes or domains)
can refer to the secrets for encryption or possibly other
uses. Secrets are identified using an UUID. See
&lt;http://libvirt.org/formatsecret.html&gt; for
documentation of the XML format used to represent properties
of secrets.</p>

<p>secret-define file Create a secret with the properties
specified in file, with no associated secret value. If file
does not specify a UUID, choose one automatically. If file
specifies an UUID of an existing secret, replace its
properties by properties defined in file, without affecting
the secret value.</p>

<p>secret-dumpxml secret Output properties of secret
(specified by its UUID) as an XML dump to stdout.</p>

<p>secret-set-value secret base64 Set the value associated
with secret (specified by its UUID) to the value
Base64-encoded value base64.</p>

<p>secret-get-value secret Output the value associated with
secret (specified by its UUID) to stdout, encoded using
Base64.</p>

<p>secret-undefine secret Delete a secret (specified by its
UUID), including the associated value, if any.</p>

<p>secret-list Output a list of UUIDs of known secrets to
stdout.</p>

<p>SNAPSHOT COMMMANDS The following commands manipulate
domain snapshots. Snapshots take the disk, memory, and
device state of a domain at a point-of-time, and save it for
future use. They have many uses, from saving a
&quot;clean&quot; copy of an OS image to saving a domains
state before a potentially destructive operation. Snapshots
are identified with a unique name. See
&lt;http://libvirt.org/formatsnapshot.html&gt; for
documentation of the XML format used to represent properties
of snapshots.</p>

<p>snapshot-create domain [xmlfile] {[--redefine
[--current]] | [--no-metadata] [--halt] [--disk-only]}
Create a snapshot for domain domain with the properties
specified in xmlfile. Normally, the only properties settable
for a domain snapshot are the &lt;name&gt; and
&lt;description&gt; elements, as well as &lt;disks&gt; if
--disk-only is given; the rest of the fields are ignored,
and automatically filled in by libvirt. If xmlfile is
completely omitted, then libvirt will choose a value for all
fields. The new snapshot will become current, as listed by
snapshot-current.</p>

<p>If --halt is specified, the domain will be left in an
inactive state after the snapshot is created.</p>

<p>If --disk-only is specified, the snapshot will only
include disk state rather than the usual system checkpoint
with vm state. Disk snapshots are faster than full system
checkpoints, but reverting to a disk snapshot may require
fsck or journal replays, since it is like the disk state at
the point when the power cord is abruptly pulled; and mixing
--halt and --disk-only loses any data that was not flushed
to disk at the time.</p>

<p>If --redefine is specified, then all XML elements
produced by snapshot-dumpxml are valid; this can be used to
migrate snapshot hierarchy from one machine to another, to
recreate hierarchy for the case of a transient domain that
goes away and is later recreated with the same name and
UUID, or to make slight alterations in the snapshot metadata
(such as host-specific aspects of the domain XML embedded in
the snapshot). When this flag is supplied, the xmlfile
argument is mandatory, and the domains current snapshot will
not be altered unless the --current flag is also given.</p>

<p>If --no-metadata is specified, then the snapshot data is
created, but any metadata is immediately discarded (that is,
libvirt does not treat the snapshot as current, and cannot
revert to the snapshot unless --redefine is later used to
teach libvirt about the metadata again).</p>

<p>Existence of snapshot metadata will prevent attempts to
undefine a persistent domain. However, for transient
domains, snapshot metadata is silently lost when the domain
quits running (whether by command such as destroy or by
internal guest action).</p>

<p>snapshot-create-as domain {[--print-xml] |
[--no-metadata] [--halt]} [name] [description] [--disk-only
[[--diskspec] diskspec]... Create a snapshot for domain
domain with the given &lt;name&gt; and &lt;description&gt;;
if either value is omitted, libvirt will choose a value. If
--print-xml is specified, then XML appropriate for
snapshot-create is output, rather than actually creating a
snapshot. Otherwise, if --halt is specified, the domain will
be left in an inactive state after the snapshot is created,
and if --disk-only is specified, the snapshot will not
include vm state.</p>

<p>The --disk-only flag is used to request a disk-only
snapshot. When this flag is in use, the command can also
take additional diskspec arguments to add &lt;disk&gt;
elements to the xml. Each &lt;diskspec&gt; is in the form
disk[,snapshot=type][,driver=type][,file=name]. To include a
literal comma in disk or in file=name, escape it with a
second comma. A literal --diskspec must preceed each
diskspec unless all three of domain, name, and description
are also present. For example, a diskspec of
&quot;vda,snapshot=external,file=/path/to,,new&quot; results
in the following XML: &lt;disk name=vda
snapshot=external&gt; &lt;source file=/path/to,new/&gt;
&lt;/disk&gt;</p>

<p>If --no-metadata is specified, then the snapshot data is
created, but any metadata is immediately discarded (that is,
libvirt does not treat the snapshot as current, and cannot
revert to the snapshot unless snapshot-create is later used
to teach libvirt about the metadata again). This flag is
incompatible with --print-xml.</p>

<p>snapshot-current domain {[--name] | [--security-info] |
[snapshotname]} Without snapshotname, this will output the
snapshot XML for the domain s current snapshot (if any). If
--name is specified, just the current snapshot name instead
of the full xml. Otherwise, using --security-info will also
include security sensitive information in the XML.</p>

<p>With snapshotname, this is a request to make the
existing named snapshot become the current snapshot, without
reverting the domain.</p>

<p>snapshot-edit domain snapshotname [--current]
{[--rename] | [--clone]} Edit the XML configuration file for
snapshotname of a domain. If --current is specified, also
force the edited snapshot to become the current
snapshot.</p>

<p>This is equivalent to:</p>

<p>virsh snapshot-dumpxml dom name &gt; snapshot.xml vi
snapshot.xml (or make changes with your other text editor)
virsh snapshot-create dom snapshot.xml --redefine
[--current]</p>

<p>except that it does some error checking.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>If --rename is specified, then the edits can change the
snapshot name. If --clone is specified, then changing the
snapshot name will create a clone of the snapshot metadata.
If neither is specified, then the edits must not change the
snapshot name. Note that changing a snapshot name must be
done with care, since the contents of some snapshots, such
as internal snapshots within a single qcow2 file, are
accessible only from the original name.</p>

<p>snapshot-list domain [{--parent | --roots}] [--metadata]
List all of the available snapshots for the given
domain.</p>

<p>If --parent is specified, add a column to the output
table giving the name of the parent of each snapshot.</p>

<p>If --roots is specified, the list will be filtered to
just snapshots that have no parents; this option is not
compatible with --parent.</p>

<p>If --metadata is specified, the list will be filtered to
just snapshots that involve libvirt metadata, and thus would
prevent undefine of a persistent domain, or be lost on
destroy of a transient domain.</p>

<p>snapshot-dumpxml domain snapshot [--security-info]
Output the snapshot XML for the domains snapshot named
snapshot. Using --security-info will also include security
sensitive information.</p>

<p>snapshot-parent domain snapshot Output the name of the
parent snapshot for the given snapshot, if any.</p>

<p>snapshot-revert domain snapshot [{--running | --paused}]
[--force] Revert the given domain to the snapshot specified
by snapshot. Be aware that this is a destructive action; any
changes in the domain since the last snapshot was taken will
be lost. Also note that the state of the domain after
snapshot-revert is complete will be the state of the domain
at the time the original snapshot was taken.</p>

<p>Normally, reverting to a snapshot leaves the domain in
the state it was at the time the snapshot was created,
except that a disk snapshot with no vm state leaves the
domain in an inactive state. Passing either the --running or
--paused flag will perform additional state changes (such as
booting an inactive domain, or pausing a running domain).
Since transient domains cannot be inactive, it is required
to use one of these flags when reverting to a disk snapshot
of a transient domain.</p>

<p>There are two cases where a snapshot revert involves
extra risk, which requires the use of --force to proceed.
One is the case of a snapshot that lacks full domain
information for reverting configuration (such as snapshots
created prior to libvirt 0.9.5); since libvirt cannot prove
that the current configuration matches what was in use at
the time of the snapshot, supplying --force assures libvirt
that the snapshot is compatible with the current
configuration (and if it is not, the domain will likely fail
to run). The other is the case of reverting from a running
domain to an active state where a new hypervisor has to be
created rather than reusing the existing hypervisor, because
it implies drawbacks such as breaking any existing VNC or
Spice connections; this condition happens with an active
snapshot that uses a provably incompatible configuration, as
well as with an inactive snapshot that is combined with the
--start or --pause flag.</p>

<p>snapshot-delete domain snapshot [--metadata]
[{--children | --children-only}] Delete the snapshot for the
domain named snapshot. If this snapshot has child snapshots,
changes from this snapshot will be merged into the children.
If --children is passed, then delete this snapshot and any
children of this snapshot. If --children-only is passed,
then delete any children of this snapshot, but leave this
snapshot intact. These two flags are mutually exclusive.</p>

<p>If --metadata is specified, then only delete the
snapshot metadata maintained by libvirt, while leaving the
snapshot contents intact for access by external tools;
otherwise deleting a snapshot also removes the data contents
from that point in time.</p>

<p>NWFILTER COMMMANDS The following commands manipulate
network filters. Network filters allow filtering of the
network traffic coming from and going to virtual machines.
Individual network traffic filters are written in XML and
may contain references to other network filters, describe
traffic filtering rules, or contain both. Network filters
are referenced by virtual machines from within their
interface description. A network filter may be referenced by
multiple virtual machines interfaces.</p>

<p>nwfilter-define xmlfile Make a new network filter known
to libvirt. If a network filter with the same name already
exists, it will be replaced with the new XML. Any running
virtual machine referencing this network filter will have
its network traffic rules adapted. If for any reason the
network traffic filtering rules cannot be instantiated by
any of the running virtual machines, then the new XML will
be rejected.</p>

<p>nwfilter-undefine nwfilter-name Delete a network filter.
The deletion will fail if any running virtual machine is
currently using this network filter.</p>

<p>nwfilter-list List all of the available network
filters.</p>

<p>nwfilter-dumpxml nwfilter-name Output the network filter
XML.</p>

<p>nwfilter-edit nwfilter-name Edit the XML of a network
filter.</p>

<p>This is equivalent to:</p>

<p>virsh nwfilter-dumpxml myfilter &gt; myfilter.xml vi
myfilter.xml (or make changes with your other text editor)
virsh nwfilter-define myfilter.xml</p>

<p>except that it does some error checking. The new network
filter may be rejected due to the same reason as mentioned
in nwfilter- define.</p>

<p>The editor used can be supplied by the $VISUAL or
$EDITOR environment variables, and defaults to
&quot;vi&quot;.</p>

<p>QEMU-SPECIFIC COMMANDS NOTE: Use of the following
commands is strongly discouraged. They can cause libvirt to
become confused and do the wrong thing on subsequent
operations. Once you have used this command, please do not
report problems to the libvirt developers; the reports will
be ignored.</p>

<p>qemu-attach pid Attach an externally launched QEMU
process to the libvirt QEMU driver. The QEMU process must
have been created with a monitor connection using the UNIX
driver. Ideally the process will also have had the -name
argument specified.</p>

<p>$ qemu-kvm -cdrom ~/demo.iso -monitor
unix:/tmp/demo,server,nowait -name foo -uuid
cece4f9f-dff0-575d-0e8e-01fe380f12ea &amp; $ QEMUPID=$! $
virsh qemu-attach $QEMUPID</p>

<p>Not all functions of libvirt are expected to work
reliably after attaching to an externally launched QEMU
process. There may be issues with the guest ABI changing
upon migration, and hotunplug may not work.</p>

<p>qemu-monitor-command domain [--hmp] command... Send an
arbitrary monitor command command to domain domain through
the qemu monitor. The results of the command will be printed
on stdout. If --hmp is passed, the command is considered to
be a human monitor command and libvirt will automatically
convert it into QMP if needed. In that case the result will
also be converted back from QMP. If more than one argument
is provided for command, they are concatenated with a space
in between before passing the single command to the
monitor.</p>

<p>ENVIRONMENT The following environment variables can be
set to alter the behaviour of &quot;virsh&quot;</p>

<p>VIRSH_DEBUG=&lt;0 to 4&gt; Turn on verbose debugging of
virsh commands. Valid levels are</p>

<p>* VIRSH_DEBUG=0 DEBUG - Messages at ALL levels get
logged</p>

<p>* VIRSH_DEBUG=1 INFO - Logs messages at levels INFO,
NOTICE, WARNING and ERROR</p>

<p>* VIRSH_DEBUG=2 NOTICE - Logs messages at levels NOTICE,
WARNING and ERROR</p>

<p>* VIRSH_DEBUG=3 WARNING - Logs messages at levels
WARNING and ERROR</p>

<p>* VIRSH_DEBUG=4 ERROR - Messages at only ERROR level
gets logged.</p>

<p>VIRSH_LOG_FILE=&quot;LOGFILE&quot; The file to log virsh
debug messages.</p>

<p>VIRSH_DEFAULT_CONNECT_URI The hypervisor to connect to
by default. Set this to a URI, in the same format as
accepted by the connect option.</p>

<p>VISUAL The editor to use by the edit and related
options.</p>

<p>EDITOR The editor to use by the edit and related
options, if &quot;VISUAL&quot; is not set.</p>

<p>LIBVIRT_DEBUG=LEVEL Turn on verbose debugging of all
libvirt API calls. Valid levels are</p>

<p>&middot; LIBVIRT_DEBUG=1</p>

<p>Messages at level DEBUG or above</p>

<p>&middot; LIBVIRT_DEBUG=2</p>

<p>Messages at level INFO or above</p>

<p>&middot; LIBVIRT_DEBUG=3</p>

<p>Messages at level WARNING or above</p>

<p>&middot; LIBVIRT_DEBUG=4</p>

<p>Messages at level ERROR or above</p>

<p>For further information about debugging options consult
&quot;http://libvirt.org/logging.html&quot;</p>

<p>BUGS Report any bugs discovered to the libvirt community
via the mailing list
&quot;http://libvirt.org/contact.html&quot; or bug tracker
&quot;http://libvirt.org/bugs.html&quot;. Alternatively
report bugs to your software distributor / vendor.</p>

<p>AUTHORS Please refer to the AUTHORS file distributed
with libvirt.</p>

<p>Based on the xm man page by: Sean Dague &lt;sean at
dague dot net&gt; Daniel Stekloff &lt;dsteklof at us dot ibm
dot com&gt;</p>

<p>COPYRIGHT Copyright (C) 2005, 2007-2010 Red Hat, Inc.,
and the authors listed in the libvirt AUTHORS file.</p>

<p>LICENSE virsh is distributed under the terms of the GNU
LGPL v2+. This is free software; see the source for copying
conditions. There is NO warranty; not even for
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE</p>

<p>SEE ALSO virt-install(1), virt-xml-validate(1),
virt-top(1), virt-df(1), &lt;http://www.libvirt.org/&gt;</p>

<p>libvirt-0.9.4 2011-11-08 VIRSH(1)</p>
<hr>
</body>
</html>
