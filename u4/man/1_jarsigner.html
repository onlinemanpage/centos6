<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 04:06:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>jarsigner(1) jarsigner(1)</p>

<p>Name jarsigner - JAR Signing and Verification Tool</p>

<p>Generates signatures for Java ARchive (JAR) files, and
verifies the signatures of signed JAR files.</p>

<p>SYNOPSIS jarsigner [ options ] jar-file alias jarsigner
-verify [ options ] jar-file [alias...]</p>

<p>The jarsigner -verify command can take zero or more
keystore alias names after the jar filename. When specified,
jarsigner will check that the certificate used to verify
each signed entry in the jar file matches one of the
keystore aliases. The aliases are defined in the keystore
specified by -keystore, or the default keystore.</p>

<p>DESCRIPTION The jarsigner tool is used for two
purposes:</p>

<p>1. to sign Java ARchive (JAR) files, and</p>

<p>2. to verify the signatures and integrity of signed JAR
files.</p>

<p>The JAR feature enables the packaging of class files,
images, sounds, and other digital data in a single file for
faster and easier distribu- tion. A tool named jar(1)
enables developers to produce JAR files. (Technically, any
zip file can also be considered a JAR file, although when
created by jar or processed by jarsigner, JAR files also
contain a META-INF/MANIFEST.MF file.)</p>

<p>A digital signature is a string of bits that is computed
from some data (the data being &quot;signed&quot;) and the
private key of an entity (a person, company, etc.). Like a
handwritten signature, a digital signature has many useful
characteristics:</p>

<p>o Its authenticity can be verified, via a computation
that uses the public key corresponding to the private key
used to generate the signature.</p>

<p>o It cannot be forged, assuming the private key is kept
secret.</p>

<p>o It is a function of the data signed and thus cant be
claimed to be the signature for other data as well.</p>

<p>o The signed data cannot be changed; if it is, the
signature will no longer verify as being authentic.</p>

<p>In order for an entitys signature to be generated for a
file, the entity must first have a public/private key pair
associated with it, and also one or more certificates
authenticating its public key. A certificate is a digitally
signed statement from one entity, saying that the public key
of some other entity has a particular value.</p>

<p>jarsigner uses key and certificate information from a
keystore to gen- erate digital signatures for JAR files. A
keystore is a database of private keys and their associated
X.509 certificate chains authenticat- ing the corresponding
public keys. The keytool(1) utility is used to create and
administer keystores.</p>

<p>jarsigner uses an entity s private key to generate a
signature. The signed JAR file contains, among other things,
a copy of the certificate from the keystore for the public
key corresponding to the private key used to sign the file.
jarsigner can verify the digital signature of the signed JAR
file using the certificate inside it (in its signature block
file).</p>

<p>jarsigner can generate signatures that include a
timestamp, thus enabling systems/deployer (including Java
Plug-in) to check whether the JAR file was signed while the
signing certificate was still valid. In addition, APIs will
allow applications to obtain the timestamp informa-
tion.</p>

<p>At this time, jarsigner can only sign JAR files created
by the SDK jar(1) tool or zip files. (JAR files are the same
as zip files, except they also have a META-INF/MANIFEST.MF
file. Such a file will automati- cally be created when
jarsigner signs a zip file.)</p>

<p>The default jarsigner behavior is to sign a JAR (or zip)
file. Use the -verify option to instead have it verify a
signed JAR file.</p>

<p>Keystore Aliases All keystore entities are accessed via
unique aliases.</p>

<p>When using jarsigner to sign a JAR file, you must
specify the alias for the keystore entry containing the
private key needed to generate the signature. For example,
the following will sign the JAR file named
&quot;MyJARFile.jar&quot;, using the private key associated
with the alias &quot;duke&quot; in the keystore named
&quot;mystore&quot; in the &quot;working&quot; directory.
Since no output file is specified, it overwrites
MyJARFile.jar with the signed JAR file.</p>

<p>jarsigner -keystore /working/mystore -storepass
&lt;keystore password&gt; -keypass &lt;private key
password&gt; MyJARFile.jar duke</p>

<p>Keystores are protected with a password, so the store
password must be specified. You will be prompted for it if
you dont specify it on the command line. Similarly, private
keys are protected in a keystore with a password, so the
private key s password must be specified, and you will be
prompted for it if you don t specify it on the command line
and it isnt the same as the store password.</p>

<p>Keystore Location jarsigner has a -keystore option for
specifying the URL of the keystore to be used. The keystore
is by default stored in a file named .keystore in the user s
home directory, as determined by the user.home system
property. On Solaris systems user.home defaults to the users
home directory.</p>

<p>Note that the input stream from the -keystore option is
passed to the KeyStore.load method. If NONE is specified as
the URL, then a null stream is passed to the KeyStore.load
method. NONE should be specified if the KeyStore is not
file-based, for example, if it resides on a hardware token
device.</p>

<p>Keystore Implementation The KeyStore class provided in
the java.security package supplies well-defined interfaces
to access and modify the information in a key- store. It is
possible for there to be multiple different concrete
implementations, where each implementation is that for a
particular type of keystore.</p>

<p>Currently, there are two command-line tools that make
use of keystore implementations (keytool and jarsigner), and
also a GUI-based tool named Policy Tool. Since KeyStore is
publicly available, Java 2 SDK users can write additional
security applications that use it.</p>

<p>There is a built-in default implementation, provided by
Sun Microsys- tems. It implements the keystore as a file,
utilizing a proprietary keystore type (format) named
&quot;JKS&quot;. It protects each private key with its
individual password, and also protects the integrity of the
entire keystore with a (possibly different) password.</p>

<p>Keystore implementations are provider-based. More
specifically, the application interfaces supplied by
KeyStore are implemented in terms of a &quot;Service
Provider Interface&quot; (SPI). That is, there is a
corresponding abstract KeystoreSpi class, also in the
java.security package, which defines the Service Provider
Interface methods that &quot;providers&quot; must implement.
(The term &quot;provider&quot; refers to a package or a set
of pack- ages that supply a concrete implementation of a
subset of services that can be accessed by the Java Security
API.) Thus, to provide a keystore implementation, clients
must implement a provider and supply a Key- storeSpi
subclass implementation, as described in How to Implement a
Provider for the Java Cryptography Architecture @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/crypto/HowToImplAProvider.html.</p>

<p>Applications can choose different types of keystore
implementations from different providers, using the
&quot;getInstance&quot; factory method sup- plied in the
KeyStore class. A keystore type defines the storage and data
format of the keystore information, and the algorithms used
to protect private keys in the keystore and the integrity of
the keystore itself. Keystore implementations of different
types are not compatible.</p>

<p>keytool works on any file-based keystore implementation.
(It treats the keystore location that is passed to it at the
command line as a file- name and converts it to a
FileInputStream, from which it loads the key- store
information.) The jarsigner and policytool tools, on the
other hand, can read a keystore from any location that can
be specified using a URL.</p>

<p>For jarsigner and keytool, you can specify a keystore
type at the com- mand line, via the -storetype option. For
Policy Tool, you can specify a keystore type via the
&quot;Change Keystore&quot; command in the Edit menu.</p>

<p>If you dont explicitly specify a keystore type, the
tools choose a keystore implementation based simply on the
value of the keystore.type property specified in the
security properties file. The security prop- erties file is
called java.security, and it resides in the SDK security
properties directory, java.home/lib/security, where
java.home is the runtime environment s directory (the jre
directory in the SDK or the top-level directory of the Java
2 Runtime Environment).</p>

<p>Each tool gets the keystore.type value and then examines
all the cur- rently-installed providers until it finds one
that implements keystores of that type. It then uses the
keystore implementation from that provider.</p>

<p>The KeyStore class defines a static method named
getDefaultType that lets applications and applets retrieve
the value of the keystore.type property. The following line
of code creates an instance of the default keystore type (as
specified in the keystore.type property):</p>

<p>KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p>The default keystore type is &quot;jks&quot; (the
proprietary type of the key- store implementation provided
by Sun). This is specified by the follow- ing line in the
security properties file:</p>

<p>keystore.type=jks</p>

<p>Note: Case doesnt matter in keystore type designations.
For example, &quot;JKS&quot; would be considered the same as
&quot;jks&quot;.</p>

<p>To have the tools utilize a keystore implementation
other than the default, change that line to specify a
different keystore type. For example, if you have a provider
package that supplies a keystore imple- mentation for a
keystore type called &quot;pkcs12&quot;, change the line
to</p>

<p>keystore.type=pkcs12</p>

<p>Note that if you us the PKCS#11 provider package, you
should refer to the KeyTool and JarSigner @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/p11guide.html#KeyToolJarSigner section of the Java
PKCS#11 Refer- ence Guide for details.</p>

<p>Supported Algorithms By default, jarsigner signs a JAR
file using one of the following:</p>

<p>o DSA (Digital Signature Algorithm) with the SHA1 digest
algorithm</p>

<p>o RSA algorithm with the SHA256 digest algorithm.</p>

<p>o EC (Elliptic Curve) cryptography algorithm with the
SHA256 with ECDSA (Elliptic Curve Digital Signature
Algorithm).</p>

<p>That is, if the signers public and private keys are DSA
keys, jar- signer will sign the JAR file using the
&quot;SHA1withDSA&quot; algorithm. If the signer s keys are
RSA keys, jarsigner will attempt to sign the JAR file using
the &quot;SHA256withRSA&quot; algorithm. If the signer s
keys are EC keys, jarsigner will sign the JAR file using the
&quot;SHA256withECDSA&quot; algorithm.</p>

<p>These default signature algorithms can be overridden
using the -sigalg option.</p>

<p>The Signed JAR File When jarsigner is used to sign a JAR
file, the output signed JAR file is exactly the same as the
input JAR file, except that it has two addi- tional files
placed in the META-INF directory:</p>

<p>o a signature file, with a .SF extension, and</p>

<p>o a signature block file, with a .DSA, .RSA, or .EC
extension.</p>

<p>The base file names for these two files come from the
value of the -sigFile option. For example, if the option
appears as</p>

<p>-sigFile MKSIGN</p>

<p>The files are named &quot;MKSIGN.SF&quot; and
&quot;MKSIGN.DSA&quot;.</p>

<p>If no -sigfile option appears on the command line, the
base file name for the .SF and .DSA files will be the first
8 characters of the alias name specified on the command
line, all converted to upper case. If the alias name has
fewer than 8 characters, the full alias name is used. If the
alias name contains any characters that are not allowed in a
signa- ture file name, each such character is converted to
an underscore (&quot;_&quot;) character in forming the file
name. Legal characters include letters, digits, underscores,
and hyphens.</p>

<p>The Signature (.SF) File</p>

<p>A signature file (the .SF file) looks similar to the
manifest file that is always included in a JAR file when
jarsigner is used to sign the file. That is, for each source
file included in the JAR file, the .SF file has three lines,
just as in the manifest file, listing the follow- ing:</p>

<p>o the file name,</p>

<p>o the name of the digest algorithm used (SHA), and</p>

<p>o a SHA digest value.</p>

<p>In the manifest file, the SHA digest value for each
source file is the digest (hash) of the binary data in the
source file. In the .SF file, on the other hand, the digest
value for a given source file is the hash of the three lines
in the manifest file for the source file.</p>

<p>The signature file also, by default, includes a header
containing a hash of the whole manifest file. The presence
of the header enables verification optimization, as
described in JAR File Verification.</p>

<p>The Signature Block File</p>

<p>The .SF file is signed and the signature is placed in
the signature block file. This file also contains, encoded
inside it, the certificate or certificate chain from the
keystore which authenticates the public key corresponding to
the private key used for signing. The file has the extension
.DSA, .RSA, or .EC depending on the digest algorithm
used.</p>

<p>Signature Timestamp jarsigner tool can generate and
store a signature timestamp when sign- ing a JAR file. In
addition, jarsigner supports alternative signing mechanisms.
This behavior is optional and is controlled by the user at
the time of signing through these options:</p>

<p>o -tsa url</p>

<p>o -tsacert alias</p>

<p>o -altsigner class</p>

<p>o -altsignerpath classpathlist</p>

<p>Each of these options is detailed in the Options section
below.</p>

<p>JAR File Verification A successful JAR file verification
occurs if the signature(s) are valid, and none of the files
that were in the JAR file when the signa- tures were
generated have been changed since then. JAR file verifica-
tion involves the following steps:</p>

<p>1. Verify the signature of the .SF file itself. That is,
the verification ensures that the signature stored in each
signature block (.DSA) file was in fact generated using the
private key corresponding to the public key whose
certificate (or certificate chain) also appears in the .DSA
file. It also ensures that the signature is a valid
signature of the corresponding sig- nature (.SF) file, and
thus the .SF file has not been tampered with.</p>

<p>2. Verify the digest listed in each entry in the .SF
file with each corresponding section in the manifest. The
.SF file by default includes a header containing a hash of
the entire manifest file. When the header is present, then
the verification can check to see whether or not the hash in
the header indeed matches the hash of the manifest file. If
that is the case, verification proceeds to the next step. If
that is not the case, a less optimized verification is
required to ensure that the hash in each source file
information section in the .SF file equals the hash of its
corresponding sec- tion in the manifest file (see The
Signature (.SF) File). One reason the hash of the manifest
file that is stored in the .SF file header may not equal the
hash of the current manifest file would be because one or
more files were added to the JAR file (using the jar tool)
after the signature (and thus the .SF file) was generated.
When the jar tool is used to add files, the manifest file is
changed (sections are added to it for the new files), but
the .SF file is not. A verification is still consid- ered
successful if none of the files that were in the JAR file
when the signature was generated have been changed since
then, which is the case if the hashes in the non-header
sections of the .SF file equal the hashes of the
corresponding sections in the manifest file.</p>

<p>3. Read each file in the JAR file that has an entry in
the .SF file. While reading, compute the files digest, and
then compare the result with the digest for this file in the
manifest section. The digests should be the same, or
verification fails.</p>

<p>If any serious verification failures occur during the
verification pro- cess, the process is stopped and a
security exception is thrown. It is caught and displayed by
jarsigner.</p>

<p>Multiple Signatures for a JAR File A JAR file can be
signed by multiple people simply by running the jar- signer
tool on the file multiple times, specifying the alias for a
dif- ferent person each time, as in:</p>

<p>jarsigner myBundle.jar susan jarsigner myBundle.jar
kevin</p>

<p>When a JAR file is signed multiple times, there are
multiple .SF and .DSA files in the resulting JAR file, one
pair for each signature. Thus, in the example above, the
output JAR file includes files with the following names:</p>

<p>SUSAN.SF SUSAN.DSA KEVIN.SF KEVIN.DSA</p>

<p>Note: It is also possible for a JAR file to have mixed
signatures, some generated by the JDK 1.1 javakey tool and
others by jarsigner. That is, jarsigner can be used to sign
JAR files already previously signed using javakey.</p>

<p>OPTIONS The various jarsigner options are listed and
described below. Note:</p>

<p>o All option names are preceded by a minus sign (-).</p>

<p>o The options may be provided in any order.</p>

<p>o Items in italics (option values) represent the actual
values that must be supplied.</p>

<p>o The -keystore, -storepass, -keypass, -sigfile,
-sigalg, -digestalg, and -signedjar options are only
relevant when signing a JAR file, not when verifying a
signed JAR file. Similarly, an alias is only specified on
the command line when signing a JAR file.</p>

<p>-keystore url Specifies the URL that tells the keystore
location. This defaults to the file .keystore in the users
home directory, as determined by the &quot;user.home&quot;
system property. A keystore is required when signing, so you
must explicitly spec- ify one if the default keystore does
not exist (or you want to use one other than the default). A
keystore is not required when verifying, but if one is
speci- fied, or the default exists, and the -verbose option
was also specified, additional information is output
regarding whether or not any of the certificates used to
verify the JAR file are con- tained in that keystore. Note:
the -keystore argument can actually be a file name (and
path) specification rather than a URL, in which case it will
be treated the same as a &quot;file:&quot; URL. That is,</p>

<p>-keystore filePathAndName</p>

<p>is treated as equivalent to</p>

<p>-keystore file:filePathAndName</p>

<p>If the Sun PKCS#11 provider has been configured in the
java.secu- rity security properties file (located in the
JREs $JAVA_HOME/lib/security directory), then keytool and
jarsigner can operate on the PKCS#11 token by specifying
these options:</p>

<p>o -keystore NONE</p>

<p>o -storetype PKCS11 For example, this command lists the
contents of the configured PKCS#11 token:</p>

<p>jarsigner -keystore NONE -storetype PKCS11 -list</p>

<p>-storetype storetype Specifies the type of keystore to
be instantiated. The default keystore type is the one that
is specified as the value of the &quot;keystore.type&quot;
property in the security properties file, which is returned
by the static getDefaultType method in java.secu-
rity.KeyStore. The PIN for a PCKS#11 token can also be
specified using the -storepass option. If none has been
specified, keytool and jar- signer will prompt for the token
PIN. If the token has a pro- tected authentication path
(such as a dedicated PIN-pad or a bio- metric reader), then
the -protected option must be specified and no password
options can be specified.</p>

<p>-storepass[:env | :file] argument Specifies the password
which is required to access the keystore. This is only
needed when signing (not verifying) a JAR file. In that
case, if a -storepass option is not provided at the command
line, the user is prompted for the password. If the modifier
env or file is not specified, then the password has the
value argument. Otherwise, the password is retrieved as
follows:</p>

<p>o env: Retrieve the password from the environment
variable named argument</p>

<p>o file: Retrieve the password from the file named
argument Note: The password shouldnt be specified on the
command line or in a script unless it is for testing
purposes, or you are on a secure system.</p>

<p>-keypass[:env | :file] argument Specifies the password
used to protect the private key of the keystore entry
addressed by the alias specified on the command line. The
password is required when using jarsigner to sign a JAR
file. If no password is provided on the command line, and
the required password is different from the store password,
the user is prompted for it. If the modifier env or file is
not specified, then the password has the value argument.
Otherwise, the password is retrieved as follows:</p>

<p>o env: Retrieve the password from the environment
variable named argument</p>

<p>o file: Retrieve the password from the file named
argument Note: The password shouldnt be specified on the
command line or in a script unless it is for testing
purposes, or you are on a secure system.</p>

<p>-sigfile file Specifies the base file name to be used
for the generated .SF and .DSA files. For example, if file
is &quot;DUKESIGN&quot;, the generated .SF and .DSA files
will be named &quot;DUKESIGN.SF&quot; and
&quot;DUKESIGN.DSA&quot;, and will be placed in the
&quot;META-INF&quot; directory of the signed JAR file. The
characters in file must come from the set
&quot;a-zA-Z0-9_-&quot;. That is, only letters, numbers,
underscore, and hyphen characters are allowed. Note: All
lowercase characters will be converted to uppercase for the
.SF and .DSA file names. If no -sigfile option appears on
the command line, the base file name for the .SF and .DSA
files will be the first 8 characters of the alias name
specified on the command line, all converted to upper case.
If the alias name has fewer than 8 characters, the full
alias name is used. If the alias name contains any charac-
ters that are not legal in a signature file name, each such
char- acter is converted to an underscore (&quot;_&quot;)
character in forming the file name.</p>

<p>-sigalg algorithm Specifies the name of the signature
algorithm to use to sign the JAR file. See Appendix A @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/crypto/CryptoSpec.html#AppA of the Java Cryptography
Archi- tecture for a list of standard signature algorithm
names. This algorithm must be compatible with the private
key used to sign the JAR file. If this option is not
specified, SHA1withDSA, SHA256withRSA, or SHA256withECDSA
will be used depending on the type of private key. There
must either be a statically installed provider supplying an
implementation of the specified algorithm or the user must
specify one with the -providerClass option, oth- erwise the
command will not succeed.</p>

<p>-digestalg algorithm Specifies the name of the message
digest algorithm to use when digesting the entries of a jar
file. See Appendix A @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/crypto/CryptoSpec.html#AppA of the Java Cryptography
Architecture for a list of standard message digest algorithm
names. If this option is not specified, SHA256 will be used.
There must either be a statically installed provider
supplying an implementation of the specified algorithm or
the user must spec- ify one with the -providerClass option,
otherwise the command will not succeed.</p>

<p>-signedjar file Specifies the name to be used for the
signed JAR file. If no name is specified on the command
line, the name used is the same as the input JAR file name
(the name of the JAR file to be signed); in other words,
that file is overwritten with the signed JAR file.</p>

<p>-verify If this appears on the command line, the
specified JAR file will be verified, not signed. If the
verification is successful, &quot;jar verified&quot; will be
displayed. If you try to verify an unsigned JAR file, or a
JAR file signed with an unsupported algorithm (e.g., RSA
when you dont have an RSA provider installed), the following
is displayed: &quot;jar is unsigned. (signatures missing or
not parsable)&quot; It is possible to verify JAR files
signed using either jarsigner or the JDK 1.1 javakey tool,
or both. For further information on verification, see JAR
File Verifica- tion.</p>

<p>-certs If this appears on the command line, along with
the -verify and -verbose options, the output includes
certificate information for each signer of the JAR file.
This information includes</p>

<p>o the name of the type of certificate (stored in the
.DSA file) that certifies the signers public key</p>

<p>o if the certificate is an X.509 certificate (more
specifically, an instance of
java.security.cert.X509Certificate): the distin- guished
name of the signer The keystore is also examined. If no
keystore value is specified on the command line, the default
keystore file (if any) will be checked. If the public key
certificate for a signer matches an entry in the keystore,
then the following information will also be dis- played:</p>

<p>o in parentheses, the alias name for the keystore entry
for that signer. If the signer actually comes from a JDK 1.1
identity database instead of from a keystore, the alias name
will appear in brackets instead of parentheses.</p>

<p>-certchain file Specifies the certificate chain to be
used, if the certificate chain associated with the private
key of the keystore entry, addressed by the alias specified
on the command line, is not com- plete. This may happen if
the keystore is located on a hardware token where there is
not enough capacity to hold a complete cer- tificate chain.
The file can be a sequence of X.509 certificates
concatenated together, or a single PKCS#7 formatted data
block, either in binary encoding format or in printable
encoding format (also known as BASE64 encoding) as defined
by the Internet RFC 1421 standard.</p>

<p>-verbose If this appears on the command line, it
indicates &quot;verbose&quot; mode, which causes jarsigner
to output extra information as to the progress of the JAR
signing or verification.</p>

<p>-internalsf In the past, the .DSA (signature block) file
generated when a JAR file was signed used to include a
complete encoded copy of the .SF file (signature file) also
generated. This behavior has been changed. To reduce the
overall size of the output JAR file, the .DSA file by
default doesnt contain a copy of the .SF file any- more. But
if -internalsf appears on the command line, the old behavior
is utilized. This option is mainly useful for testing; in
practice, it should not be used, since doing so eliminates a
useful optimization.</p>

<p>-sectionsonly If this appears on the command line, the
.SF file (signature file) generated when a JAR file is
signed does not include a header containing a hash of the
whole manifest file. It just con- tains information and
hashes related to each individual source file included in
the JAR file, as described in The Signature (.SF) File . By
default, this header is added, as an optimization. When the
header is present, then whenever the JAR file is verified,
the verification can first check to see whether or not the
hash in the header indeed matches the hash of the whole
manifest file. If so, verification proceeds to the next
step. If not, it is neces- sary to do a less optimized
verification that the hash in each source file information
section in the .SF file equals the hash of its corresponding
section in the manifest file. For further information, see
JAR File Verification. This option is mainly useful for
testing; in practice, it should not be used, since doing so
eliminates a useful optimization.</p>

<p>-protected Either true or false. This value should be
specified as true if a password must be given via a
protected authentication path such as a dedicated PIN
reader.</p>

<p>-providerClass provider-class-name Used to specify the
name of cryptographic service providers mas- ter class file
when the service provider is not listed in the security
properties file, java.security. Used in conjunction with the
-providerArg ConfigFilePath option, keytool and jarsigner
will install the provider dynamically (where ConfigFilePath
is the path to the token configuration file). Here s an
example of a command to list a PKCS#11 keystore when the Sun
PKCS#11 provider has not been configured in the security
properties file.</p>

<p>jarsigner -keystore NONE -storetype PKCS11
-providerClass sun.security.pkcs11.SunPKCS11 -providerArg
/foo/bar/token.config -list</p>

<p>-providerName providerName If more than one provider has
been configured in the java.secu- rity security properties
file, you can use the -providerName option to target a
specific provider instance. The argument to this option is
the name of the provider. For the Sun PKCS#11 provider,
providerName is of the form SunPKCS11-TokenName, where
TokenName is the name suffix that the provider instance has
been configured with, as detailed in the configuration
attributes table @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/p11guide.html#ATTRS. For example, the following command
lists the contents of the PKCS#11 keystore provider instance
with name suffix SmartCard:</p>

<p>jarsigner -keystore NONE -storetype PKCS11 -providerName
SunPKCS11-SmartCard -list</p>

<p>-Jjavaoption Passes through the specified javaoption
string directly to the Java interpreter. (jarsigner is
actually a &quot;wrapper&quot; around the interpreter.) This
option should not contain any spaces. It is useful for
adjusting the execution environment or memory usage. For a
list of possible interpreter options, type java -h or java
-X at the command line.</p>

<p>-tsa url If &quot;-tsa http://example.tsa.url&quot;
appears on the command line when signing a JAR file then a
timestamp is generated for the signa- ture. The URL,
http://example.tsa.url, identifies the location of the Time
Stamping Authority (TSA). It overrides any URL found via the
-tsacert option. The -tsa option does not require the TSAs
public key certificate to be present in the keystore. To
generate the timestamp, jarsigner communicates with the TSA
using the Time-Stamp Protocol (TSP) defined in RFC 3161 @
http://www.ietf.org/rfc/rfc3161.txt. If successful, the
timestamp token returned by the TSA is stored along with the
signature in the signature block file.</p>

<p>-tsacert alias If &quot;-tsacert alias&quot; appears on
the command line when signing a JAR file then a timestamp is
generated for the signature. The alias identifies the TSAs
public key certificate in the keystore that is currently in
effect. The entrys certificate is examined for a Subject
Information Access extension that contains a URL identifying
the location of the TSA. The TSA s public key certificate
must be present in the keystore when using -tsacert.</p>

<p>-altsigner class Specifies that an alternative signing
mechanism be used. The fully-qualified class name identifies
a class file that extends the
com.sun.jarsigner.ContentSigner abstract class. The path to
this class file is defined by the -altsignerpath option. If
the -altsigner option is used, jarsigner uses the signing
mechanism provided by the specified class. Otherwise,
jarsigner uses its default signing mechanism. For example,
to use the signing mechanism provided by a class named
com.sun.sun.jarsigner.AuthSigner, use the jarsigner option
&quot;-altsigner com.sun.jarsigner.AuthSigner&quot;</p>

<p>-altsignerpath classpathlist Specifies the path to the
class file (the class file name is specified with the
-altsigner option described above) and any JAR files it
depends on. If the class file is in a JAR file, then this
specifies the path to that JAR file, as shown in the example
below. An absolute path or a path relative to the current
directory may be specified. If classpathlist contains
multiple paths or JAR files, they should be separated with a
colon (:) on Solaris and a semi-colon (;) on Windows. This
option is not necessary if the class is already in the
search path. Example of specifying the path to a jar file
that contains the class file:</p>

<p>-altsignerpath /home/user/lib/authsigner.jar</p>

<p>Note that the JAR file name is included. Example of
specifying the path to the jar file that contains the class
file:</p>

<p>-altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</p>

<p>Note that the JAR file name is omitted.</p>

<p>-strict During the signing or verifying process, some
warning messages may be shown. If this option appears on the
command line, the exit code of the tool will reflect the
warning messages that are found. Read the
&quot;WARNINGS&quot; section for details.</p>

<p>-verbose:sub-options For the verifying process, the
-verbose option takes sub-options to determine how much
information will be shown. If -certs is also specified, the
default mode (or sub-option all) displays each entry as it
is being processed and following that, the cer- tificate
information for each signer of the JAR file. If -certs and
the -verbose:grouped sub-option are specified, entries with
the same signer info are grouped and displayed together
along with their certificate information. If -certs and the
-ver- bose:summary sub-option are specified, then entries
with the same signer info are grouped and displayed together
along with their certificate information but details about
each entry are summa- rized and displayed as &quot;one entry
(and more)&quot;. See the examples section for more
information.</p>

<p>EXAMPLES Signing a JAR File Suppose you have a JAR file
named &quot;bundle.jar&quot; and you d like to sign it using
the private key of the user whose keystore alias is
&quot;jane&quot; in the keystore named &quot;mystore&quot;
in the &quot;working&quot; directory. You can use the
following to sign the JAR file and name the signed JAR file
&quot;sbun- dle.jar&quot;:</p>

<p>jarsigner -keystore /working/mystore -storepass
&lt;keystore password&gt; -keypass &lt;private key
password&gt; -signedjar sbundle.jar bundle.jar jane</p>

<p>Note that there is no -sigfile specified in the command
above, so the generated .SF and .DSA files to be placed in
the signed JAR file will have default names based on the
alias name. That is, they will be named JANE.SF and
JANE.DSA.</p>

<p>If you want to be prompted for the store password and
the private key password, you could shorten the above
command to</p>

<p>jarsigner -keystore /working/mystore -signedjar
sbundle.jar bundle.jar jane</p>

<p>If the keystore to be used is the default keystore (the
one named &quot;.keystore&quot; in your home directory), you
dont need to specify a key- store, as in:</p>

<p>jarsigner -signedjar sbundle.jar bundle.jar jane</p>

<p>Finally, if you want the signed JAR file to simply
overwrite the input JAR file (bundle.jar), you don t need to
specify a -signedjar option:</p>

<p>jarsigner bundle.jar jane</p>

<p>Verifying a Signed JAR File To verify a signed JAR file,
that is, to verify that the signature is valid and the JAR
file has not been tampered with, use a command such as the
following:</p>

<p>jarsigner -verify sbundle.jar</p>

<p>If the verification is successful,</p>

<p>jar verified.</p>

<p>is displayed. Otherwise, an error message appears.</p>

<p>You can get more information if you use the -verbose
option. A sample use of jarsigner with the -verbose option
is shown below, along with sample output:</p>

<p>jarsigner -verify -verbose sbundle.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA smk 2752 Fri Sep
26 16:12:30 PDT 1997 AclEx.class smk 849 Fri Sep 26 16:12:46
PDT 1997 test.class</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>Verification with Certificate Information If you specify
the -certs option when verifying, along with the -verify and
-verbose options, the output includes certificate
information for each signer of the JAR file, including the
certificate type, the signer distinguished name information
(if and only if it s an X.509 certifi- cate), and, in
parentheses, the keystore alias for the signer if the public
key certificate in the JAR file matches that in a keystore
entry. For example,</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs myTest.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 208 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.SF 1087 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.DSA smk 2752 Fri Sep 26
16:12:30 PDT 1997 Tst.class</p>

<p>X.509, CN=Test Group, OU=Java Software, O=Sun
Microsystems, L=CUP, S=CA, C=US (javatest) X.509, CN=Jane
Smith, OU=Java Software, O=Sun, L=cup, S=ca, C=us (jane)</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>If the certificate for a signer is not an X.509
certificate, there is no distinguished name information. In
that case, just the certificate type and the alias are
shown. For example, if the certificate is a PGP certificate,
and the alias is &quot;bob&quot;, youd get</p>

<p>PGP, (bob)</p>

<p>Verification of a JAR File that Includes Identity
Database Signers If a JAR file has been signed using the JDK
1.1 javakey tool, and thus the signer is an alias in an
identity database, the verification output includes an
&quot;i&quot; symbol. If the JAR file has been signed by
both an alias in an identity database and an alias in a
keystore, both &quot;k&quot; and &quot;i&quot; appear.</p>

<p>When the -certs option is used, any identity database
aliases are shown in square brackets rather than the
parentheses used for keystore aliases. For example:</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs writeFile.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 199 Fri Sep 27
12:22:30 PDT 1997 META-INF/DUKE.SF 1013 Fri Sep 27 12:22:30
PDT 1997 META-INF/DUKE.DSA smki 2752 Fri Sep 26 16:12:30 PDT
1997 writeFile.html</p>

<p>X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup,
S=ca, C=us (jane) X.509, CN=Duke, OU=Java Software, O=Sun,
L=cup, S=ca, C=us [duke]</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in keystore
i = at least one certificate was found in identity scope</p>

<p>jar verified.</p>

<p>Note that the alias &quot;duke&quot; is in brackets to
denote that it is an iden- tity database alias, not a
keystore alias.</p>

<p>WARNINGS During the signing/verifying process, jarsigner
may display various warnings. These warning codes are
defined as follows:</p>

<p>hasExpiringCert 2 This jar contains entries whose signer
certificate will expire within six months</p>

<p>hasExpiredCert 4 This jar contains entries whose signer
certificate has expired.</p>

<p>notYetValidCert 4 This jar contains entries whose signer
certificate is not yet valid.</p>

<p>chainNotValidated 4 This jar contains entries whose
certificate chain cannot be correctly validated.</p>

<p>badKeyUsage 8 This jar contains entries whose signer
certificats KeyUsage extension doest allow code signing.</p>

<p>badExtendedKeyUsage 8 This jar contains entries whose
signer certificats ExtendedKeyUsage extension doest allow
code signing.</p>

<p>badNetscapeCertType 8 This jar contains entries whose
signer certificats NetscapeCertType extension doest allow
code signing.</p>

<p>hasUnsignedEntry 16 This jar contains unsigned entries
which have not been integrity-checked.</p>

<p>notSignedByAlias 32 This jar contains signed entries
which are not signed by the specified alias(es)</p>

<p>aliasNotInStore 32 This jar contains signed entries that
are not signed by alias in this keystore</p>

<p>When the -strict option is provided, an OR-value of
warnings detected will be returned as the exit code of the
tool. For example, if a cer- tificate used to sign an entry
is expired and has a keyUsage extension that does not allow
it to sign a file, an exit code 12 (=4+8) will be
returned.</p>

<p>Note: Exit codes are reused because only 0-255 is legal
for Unix. In any case, if the signing/verifying process
fails, the following exit code will be returned:</p>

<p>failure 1</p>

<p>Compatibility with JDK 1.1 The keytool and jarsigner
tools completely replace the javakey tool provided in JDK
1.1. These new tools provide more features than javakey,
including the ability to protect the keystore and private
keys with passwords, and the ability to verify signatures in
addition to generating them.</p>

<p>The new keystore architecture replaces the identity
database that javakey created and managed. There is no
backwards compatibility between the keystore format and the
database format used by javakey in 1.1. However,</p>

<p>o It is possible to import the information from an
identity database into a keystore, via the keytool
-identitydb command.</p>

<p>o jarsigner can sign JAR files also previously signed
using javakey.</p>

<p>o jarsigner can verify JAR files signed using javakey.
Thus, it rec- ognizes and can work with signer aliases that
are from a JDK 1.1 identity database rather than a Java 2
SDK keystore.</p>

<p>The following table explains how JAR files that were
signed in JDK 1.1.x are treated in the Java 2 platform.</p>

<p>Notes:</p>

<p>1. If an identity/alias is mentioned in the policy file,
it must be imported into the keystore for the policy file to
have any effect on privileges granted.</p>

<p>2. The policy file/keystore combination has precedence
over a trusted identity in the identity database.</p>

<p>3. Untrusted identities are ignored in the Java 2
platform.</p>

<p>4. Only trusted identities can be imported into Java 2
SDK key- stores.</p>

<p>SEE ALSO o jar(1) tool documentation</p>

<p>o keytool(1) tool documentation</p>

<p>o the Security @
http://docs.oracle.com/javase/tutorial/security/index.html
trail of the Java Tutorial @
http://docs.oracle.com/javase/tutorial/index.html for
examples of the use of the jarsigner tool</p>

<p>16 Mar 2012 jarsigner(1)</p>
<hr>
</body>
</html>
