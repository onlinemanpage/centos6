<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 04:37:29 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT STA_INFO(9) Internals STRUCT STA_INFO(9)</p>

<p>NAME struct_sta_info - STA information</p>

<p>SYNOPSIS struct sta_info { struct list_head list; struct
sta_info __rcu * hnext; struct ieee80211_local * local;
struct ieee80211_sub_if_data * sdata; struct ieee80211_key
__rcu * gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];
struct ieee80211_key __rcu * ptk; struct rate_control_ref *
rate_ctrl; void * rate_ctrl_priv; spinlock_t lock; struct
work_struct drv_unblock_wk; u16 listen_interval; bool dead;
bool uploaded; enum ieee80211_sta_state sta_state; unsigned
long _flags; struct sk_buff_head
ps_tx_buf[IEEE80211_NUM_ACS]; struct sk_buff_head
tx_filtered[IEEE80211_NUM_ACS]; unsigned long
driver_buffered_tids; unsigned long rx_packets; unsigned
long rx_bytes; unsigned long wep_weak_iv_count; unsigned
long last_rx; long last_connected; unsigned long
num_duplicates; unsigned long rx_fragments; unsigned long
rx_dropped; int last_signal; struct ewma avg_signal; __le16
last_seq_ctrl[NUM_RX_DATA_QUEUES + 1]; unsigned long
tx_filtered_count; unsigned long tx_retry_failed; unsigned
long tx_retry_count; unsigned int fail_avg; unsigned long
tx_packets; unsigned long tx_bytes; unsigned long
tx_fragments; struct ieee80211_tx_rate last_tx_rate; int
last_rx_rate_idx; int last_rx_rate_flag; u16
tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1]; struct
sta_ampdu_mlme ampdu_mlme; u8 timer_to_tid[STA_TID_NUM];
#ifdef CONFIG_MAC80211_MESH __le16 llid; __le16 plid; __le16
reason; u8 plink_retries; bool ignore_plink_timer; bool
plink_timer_was_running; enum nl80211_plink_state
plink_state; u32 plink_timeout; struct timer_list
plink_timer; s64 t_offset; s64 t_offset_setpoint; enum
nl80211_channel_type ch_type; #endif #ifdef
CONFIG_MAC80211_DEBUGFS struct sta_info_debugfsdentries
debugfs; #endif unsigned int lost_packets; unsigned int
beacon_loss_count; bool supports_40mhz; struct ieee80211_sta
sta; };</p>

<p>MEMBERS list global linked list entry</p>

<p>hnext hash table linked list pointer</p>

<p>local pointer to the global information</p>

<p>sdata virtual interface this station belongs to</p>

<p>gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS] group keys
negotiated with this station, if any</p>

<p>ptk peer key negotiated with this station, if any</p>

<p>rate_ctrl rate control algorithm reference</p>

<p>rate_ctrl_priv rate control private per-STA pointer</p>

<p>lock used for locking all fields that require locking,
see comments in the header file.</p>

<p>drv_unblock_wk used for driver PS unblocking</p>

<p>listen_interval listen interval of this station, when
we&acute;re acting as AP</p>

<p>dead set to true when sta is unlinked</p>

<p>uploaded set to true when sta is uploaded to the
driver</p>

<p>sta_state duplicates information about station state
(for debug)</p>

<p>_flags STA flags, see enum ieee80211_sta_info_flags, do
not use directly</p>

<p>ps_tx_buf[IEEE80211_NUM_ACS] buffers (per AC) of frames
to transmit to this station when it leaves power saving
state or polls</p>

<p>tx_filtered[IEEE80211_NUM_ACS] buffers (per AC) of
frames we already tried to transmit but were filtered by
hardware due to STA having entered power saving state, these
are also delivered to the station when it leaves powersave
or polls for frames</p>

<p>driver_buffered_tids bitmap of TIDs the driver has data
buffered on</p>

<p>rx_packets Number of MSDUs received from this STA</p>

<p>rx_bytes Number of bytes received from this STA</p>

<p>wep_weak_iv_count number of weak WEP IVs received from
this station</p>

<p>last_rx time (in jiffies) when last frame was received
from this STA</p>

<p>last_connected time (in seconds) when a station got
connected</p>

<p>num_duplicates number of duplicate frames received from
this STA</p>

<p>rx_fragments number of received MPDUs</p>

<p>rx_dropped number of dropped MPDUs from this STA</p>

<p>last_signal signal of last received frame from this
STA</p>

<p>avg_signal moving average of signal of received frames
from this STA</p>

<p>last_seq_ctrl[NUM_RX_DATA_QUEUES + 1] last received
seq/frag number from this STA (per RX queue)</p>

<p>tx_filtered_count number of frames the hardware filtered
for this STA</p>

<p>tx_retry_failed number of frames that failed retry</p>

<p>tx_retry_count total number of retries for frames to
this STA</p>

<p>fail_avg moving percentage of failed MSDUs</p>

<p>tx_packets number of RX/TX MSDUs</p>

<p>tx_bytes number of bytes transmitted to this STA</p>

<p>tx_fragments number of transmitted MPDUs</p>

<p>last_tx_rate rate used for last transmit, to report to
userspace as the transmit rate</p>

<p>last_rx_rate_idx rx status rate index of the last data
packet</p>

<p>last_rx_rate_flag rx status flag of the last data
packet</p>

<p>tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1] per-TID sequence
numbers for sending to this STA</p>

<p>ampdu_mlme A-MPDU state machine state</p>

<p>timer_to_tid[STA_TID_NUM] identity mapping to ID
timers</p>

<p>llid Local link ID</p>

<p>plid Peer link ID</p>

<p>reason Cancel reason on PLINK_HOLDING state</p>

<p>plink_retries Retries in establishment</p>

<p>ignore_plink_timer ignore the peer-link timer (used
internally)</p>

<p>plink_timer_was_running used by suspend/resume to
restore timers</p>

<p>plink_state peer link state</p>

<p>plink_timeout timeout of peer link</p>

<p>plink_timer peer link watch timer</p>

<p>t_offset timing offset relative to this host</p>

<p>t_offset_setpoint reference timing offset of this sta to
be used when calculating clockdrift</p>

<p>ch_type peer&acute;s channel type</p>

<p>debugfs debug filesystem info</p>

<p>lost_packets number of consecutive lost packets</p>

<p>beacon_loss_count number of times beacon loss has
triggered</p>

<p>supports_40mhz tracks whether the station advertised 40
MHz support as we overwrite its HT parameters with the
currently used value</p>

<p>sta station information we share with the driver</p>

<p>DESCRIPTION This structure collects information about a
station that mac80211 is communicating with.</p>

<p>AUTHOR Johannes Berg &lt;johannes@sipsolutions.net&gt;
Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. January 2013 STRUCT
STA_INFO(9)</p>
<hr>
</body>
</html>
