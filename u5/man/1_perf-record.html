<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 04:14:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERF-RECORD(1) perf Manual PERF-RECORD(1)</p>

<p>NAME perf-record - Run a command and record its profile
into perf.data</p>

<p>SYNOPSIS perf record [-e &lt;EVENT&gt; | --event=EVENT]
[-l] [-a] &lt;command&gt; perf record [-e &lt;EVENT&gt; |
--event=EVENT] [-l] [-a] &lt;command&gt;
[&lt;options&gt;]</p>

<p>DESCRIPTION This command runs a command and gathers a
performance counter profile from it, into perf.data -
without displaying anything.</p>

<p>This file can then be inspected later on, using perf
report.</p>

<p>OPTIONS &lt;command&gt;... Any command you can specify
in a shell.</p>

<p>-e, --event= Select the PMU event. Selection can be a
symbolic event name (use perf list to list all events) or a
raw PMU event (eventsel+umask) in the form of rNNN where NNN
is a hexadecimal event descriptor.</p>

<p>--filter=&lt;filter&gt; Event filter.</p>

<p>-a, --all-cpus System-wide collection from all CPUs.</p>

<p>-l Scale counter values.</p>

<p>-p, --pid= Record events on existing process ID (comma
separated list).</p>

<p>-t, --tid= Record events on existing thread ID (comma
separated list).</p>

<p>-u, --uid= Record events in threads owned by uid. Name
or number.</p>

<p>-r, --realtime= Collect data with this RT SCHED_FIFO
priority.</p>

<p>-D, --no-delay Collect data without buffering.</p>

<p>-A, --append Append to the output file to do incremental
profiling.</p>

<p>-f, --force Overwrite existing data file.
(deprecated)</p>

<p>-c, --count= Event period to sample.</p>

<p>-o, --output= Output file name.</p>

<p>-i, --no-inherit Child tasks do not inherit
counters.</p>

<p>-F, --freq= Profile at this frequency.</p>

<p>-m, --mmap-pages= Number of mmap data pages. Must be a
power of two.</p>

<p>-g, --call-graph Do call-graph (stack chain/backtrace)
recording.</p>

<p>-q, --quiet Dont print any message, useful for
scripting.</p>

<p>-v, --verbose Be more verbose (show counter open errors,
etc).</p>

<p>-s, --stat Per thread counts.</p>

<p>-d, --data Sample addresses.</p>

<p>-T, --timestamp Sample timestamps. Use it with perf
report -D to see the timestamps, for instance.</p>

<p>-n, --no-samples Dont sample.</p>

<p>-R, --raw-samples Collect raw sample records from all
opened counters (default for tracepoint counters).</p>

<p>-C, --cpu Collect samples only on the list of CPUs
provided. Multiple CPUs can be provided as a comma-separated
list with no space: 0,1. Ranges of CPUs are specified with
-: 0-2. In per-thread mode with inheritance mode on
(default), samples are captured only when the thread
executes on the designated CPUs. Default is to monitor all
CPUs.</p>

<p>-N, --no-buildid-cache Do not update the builid cache.
This saves some overhead in situations where the information
in the perf.data file (which includes buildids) is
sufficient.</p>

<p>-G name,..., --cgroup name,... monitor only in the
container (cgroup) called &quot;name&quot;. This option is
available only in per-cpu mode. The cgroup filesystem must
be mounted. All threads belonging to container
&quot;name&quot; are monitored when they run on the
monitored CPUs. Multiple cgroups can be provided. Each
cgroup is applied to the corresponding event, i.e., first
cgroup to first event, second cgroup to second event and so
on. It is possible to provide an empty cgroup (monitor all
the time) using, e.g., -G foo,,bar. Cgroups must have
corresponding events, i.e., they always refer to events
defined earlier on the command line.</p>

<p>-b, --branch-any Enable taken branch stack sampling. Any
type of taken branch may be sampled. This is a shortcut for
--branch-filter any. See --branch-filter for more infos.</p>

<p>-j, --branch-filter Enable taken branch stack sampling.
Each sample captures a series of consecutive taken branches.
The number of branches captured with each sample depends on
the underlying hardware, the type of branches of interest,
and the executed code. It is possible to select the types of
branches captured by enabling filters. The following filters
are defined:</p>

<p>&middot; any: any type of branches</p>

<p>&middot; any_call: any function call or system call</p>

<p>&middot; any_ret: any function return or system call
return</p>

<p>&middot; ind_call: any indirect branch</p>

<p>&middot; u: only when the branch target is at the user
level</p>

<p>&middot; k: only when the branch target is in the
kernel</p>

<p>&middot; hv: only when the target is at the hypervisor
level The option requires at least one branch type among
any, any_call, any_ret, ind_call. The privilege levels may
be omitted, in which case, the privilege levels of the
associated event are applied to the branch filter. Both
kernel (k) and hypervisor (hv) privilege levels are subject
to permissions. When sampling on multiple events, branch
stack sampling is enabled for all the sampling events. The
sampled branch type is the same for all events. The various
filters must be specified as a comma separated list:
--branch-filter any_ret,u,k Note that this feature may not
be available on all processors.</p>

<p>SEE ALSO perf-stat(1), perf-list(1)</p>

<p>perf 11/10/2013 PERF-RECORD(1)</p>
<hr>
</body>
</html>
