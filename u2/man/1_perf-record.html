<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 05:09:39 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERF-RECORD(1) perf Manual PERF-RECORD(1)</p>

<p>NAME perf-record - Run a command and record its profile
into perf.data</p>

<p>SYNOPSIS perf record [-e &lt;EVENT&gt; | --event=EVENT]
[-l] [-a] &lt;command&gt; perf record [-e &lt;EVENT&gt; |
--event=EVENT] [-l] [-a] &lt;command&gt;
[&lt;options&gt;]</p>

<p>DESCRIPTION This command runs a command and gathers a
performance counter profile from it, into perf.data -
without displaying anything.</p>

<p>This file can then be inspected later on, using perf
report.</p>

<p>OPTIONS &lt;command&gt;... Any command you can specify
in a shell.</p>

<p>-e, --event= Select the PMU event. Selection can be a
symbolic event name (use perf list to list all events) or a
raw PMU event (eventsel+umask) in the form of rNNN where NNN
is a hexadecimal event descriptor.</p>

<p>--filter=&lt;filter&gt; Event filter.</p>

<p>-a, --all-cpus System-wide collection from all CPUs.</p>

<p>-l Scale counter values.</p>

<p>-p, --pid= Record events on existing process ID.</p>

<p>-t, --tid= Record events on existing thread ID.</p>

<p>-r, --realtime= Collect data with this RT SCHED_FIFO
priority.</p>

<p>-D, --no-delay Collect data without buffering.</p>

<p>-A, --append Append to the output file to do incremental
profiling.</p>

<p>-f, --force Overwrite existing data file.
(deprecated)</p>

<p>-c, --count= Event period to sample.</p>

<p>-o, --output= Output file name.</p>

<p>-i, --no-inherit Child tasks do not inherit
counters.</p>

<p>-F, --freq= Profile at this frequency.</p>

<p>-m, --mmap-pages= Number of mmap data pages.</p>

<p>-g, --call-graph Do call-graph (stack chain/backtrace)
recording.</p>

<p>-q, --quiet Dont print any message, useful for
scripting.</p>

<p>-v, --verbose Be more verbose (show counter open errors,
etc).</p>

<p>-s, --stat Per thread counts.</p>

<p>-d, --data Sample addresses.</p>

<p>-T, --timestamp Sample timestamps. Use it with perf
report -D to see the timestamps, for instance.</p>

<p>-n, --no-samples Dont sample.</p>

<p>-R, --raw-samples Collect raw sample records from all
opened counters (default for tracepoint counters).</p>

<p>-C, --cpu Collect samples only on the list of CPUs
provided. Multiple CPUs can be provided as a comma-separated
list with no space: 0,1. Ranges of CPUs are specified with
-: 0-2. In per-thread mode with inheritance mode on
(default), samples are captured only when the thread
executes on the designated CPUs. Default is to monitor all
CPUs.</p>

<p>-N, --no-buildid-cache Do not update the builid cache.
This saves some overhead in situations where the information
in the perf.data file (which includes buildids) is
sufficient.</p>

<p>-G name,..., --cgroup name,... monitor only in the
container (cgroup) called &quot;name&quot;. This option is
available only in per-cpu mode. The cgroup filesystem must
be mounted. All threads belonging to container
&quot;name&quot; are monitored when they run on the
monitored CPUs. Multiple cgroups can be provided. Each
cgroup is applied to the corresponding event, i.e., first
cgroup to first event, second cgroup to second event and so
on. It is possible to provide an empty cgroup (monitor all
the time) using, e.g., -G foo,,bar. Cgroups must have
corresponding events, i.e., they always refer to events
defined earlier on the command line.</p>

<p>SEE ALSO perf-stat(1), perf-list(1)</p>

<p>perf 2.6.32-220.el6.x 11/09/2011 PERF-RECORD(1)</p>
<hr>
</body>
</html>
