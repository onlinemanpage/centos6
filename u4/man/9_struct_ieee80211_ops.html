<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Fri Nov 18 04:37:20 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT IEEE80211_OPS(9) The basic mac80211 driver inte
STRUCT IEEE80211_OPS(9)</p>

<p>NAME struct_ieee80211_ops - callbacks from mac80211 to
the driver</p>

<p>SYNOPSIS struct ieee80211_ops { void (* tx) (struct
ieee80211_hw *hw, struct sk_buff *skb); void (* tx_frags)
(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct
ieee80211_sta *sta, struct sk_buff_head *skbs); int (*
start) (struct ieee80211_hw *hw); void (* stop) (struct
ieee80211_hw *hw); #ifdef CONFIG_PM int (* suspend) (struct
ieee80211_hw *hw, struct cfg80211_wowlan *wowlan); int (*
resume) (struct ieee80211_hw *hw); void (* set_wakeup)
(struct ieee80211_hw *hw, bool enabled); #endif int (*
add_interface) (struct ieee80211_hw *hw,struct ieee80211_vif
*vif); int (* change_interface) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif,enum nl80211_iftype new_type,
bool p2p); void (* remove_interface) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif); int (* config) (struct
ieee80211_hw *hw, u32 changed); void (* bss_info_changed)
(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct
ieee80211_bss_conf *info,u32 changed); u64 (*)(struct
ieee80211_hw *hw,,if 0 prepare_multicast; #else #endif void
(* configure_filter) (struct ieee80211_hw *hw,unsigned int
changed_flags,unsigned int *total_flags,u64 multicast); int
(* set_tim) (struct ieee80211_hw *hw, struct ieee80211_sta
*sta,bool set); int (* set_key) (struct ieee80211_hw *hw,
enum set_key_cmd cmd,struct ieee80211_vif *vif, struct
ieee80211_sta *sta,struct ieee80211_key_conf *key); void (*
update_tkip_key) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct
ieee80211_sta *sta,u32 iv32, u16 *phase1key); void (*
set_rekey_data) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
int (* hw_scan) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,struct cfg80211_scan_request *req); void
(* cancel_hw_scan) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); int (* sched_scan_start) (struct
ieee80211_hw *hw,struct ieee80211_vif *vif,struct
cfg80211_sched_scan_request *req,struct
ieee80211_sched_scan_ies *ies); void (* sched_scan_stop)
(struct ieee80211_hw *hw,struct ieee80211_vif *vif); void (*
sw_scan_start) (struct ieee80211_hw *hw); void (*
sw_scan_complete) (struct ieee80211_hw *hw); int (*
get_stats) (struct ieee80211_hw *hw,struct
ieee80211_low_level_stats *stats); void (* get_tkip_seq)
(struct ieee80211_hw *hw, u8 hw_key_idx,u32 *iv32, u16
*iv16); int (* set_frag_threshold) (struct ieee80211_hw *hw,
u32 value); int (* set_rts_threshold) (struct ieee80211_hw
*hw, u32 value); int (* sta_add) (struct ieee80211_hw *hw,
struct ieee80211_vif *vif,struct ieee80211_sta *sta); int (*
sta_remove) (struct ieee80211_hw *hw, struct ieee80211_vif
*vif,struct ieee80211_sta *sta); void (* sta_notify) (struct
ieee80211_hw *hw, struct ieee80211_vif *vif,enum
sta_notify_cmd, struct ieee80211_sta *sta); int (*
sta_state) (struct ieee80211_hw *hw, struct ieee80211_vif
*vif,struct ieee80211_sta *sta,enum ieee80211_sta_state
old_state,enum ieee80211_sta_state new_state); void (*
sta_rc_update) (struct ieee80211_hw *hw,struct ieee80211_vif
*vif,struct ieee80211_sta *sta,u32 changed); int (* conf_tx)
(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16
ac,const struct ieee80211_tx_queue_params *params); u64 (*
get_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif
*vif); void (* set_tsf) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,u64 tsf); void (* reset_tsf) (struct
ieee80211_hw *hw, struct ieee80211_vif *vif); int (*
tx_last_beacon) (struct ieee80211_hw *hw); int (*
ampdu_action) (struct ieee80211_hw *hw,struct ieee80211_vif
*vif,enum ieee80211_ampdu_mlme_action action,struct
ieee80211_sta *sta, u16 tid, u16 *ssn,u8 buf_size); int (*
get_survey) (struct ieee80211_hw *hw, int idx,struct
survey_info *survey); void (* rfkill_poll) (struct
ieee80211_hw *hw); void (* set_coverage_class) (struct
ieee80211_hw *hw, u8 coverage_class); #ifdef
CONFIG_NL80211_TESTMODE int (* testmode_cmd) (struct
ieee80211_hw *hw, void *data, int len); int (*
testmode_dump) (struct ieee80211_hw *hw, struct sk_buff
*skb,struct netlink_callback *cb,void *data, int len);
#endif void (* flush) (struct ieee80211_hw *hw, bool drop);
void (* channel_switch) (struct ieee80211_hw *hw,struct
ieee80211_channel_switch *ch_switch); int (* napi_poll)
(struct ieee80211_hw *hw, int budget); int (* set_antenna)
(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant); int (*
get_antenna) (struct ieee80211_hw *hw, u32 *tx_ant, u32
*rx_ant); int (* remain_on_channel) (struct ieee80211_hw
*hw,struct ieee80211_channel *chan,enum nl80211_channel_type
channel_type,int duration); int (* cancel_remain_on_channel)
(struct ieee80211_hw *hw); int (* set_ringparam) (struct
ieee80211_hw *hw, u32 tx, u32 rx); void (* get_ringparam)
(struct ieee80211_hw *hw,u32 *tx, u32 *tx_max, u32 *rx, u32
*rx_max); bool (* tx_frames_pending) (struct ieee80211_hw
*hw); int (* set_bitrate_mask) (struct ieee80211_hw *hw,
struct ieee80211_vif *vif,const struct cfg80211_bitrate_mask
*mask); void (* rssi_callback) (struct ieee80211_hw *hw,enum
ieee80211_rssi_event rssi_event); void (*
allow_buffered_frames) (struct ieee80211_hw *hw,struct
ieee80211_sta *sta,u16 tids, int num_frames,enum
ieee80211_frame_release_type reason,bool more_data); void (*
release_buffered_frames) (struct ieee80211_hw *hw,struct
ieee80211_sta *sta,u16 tids, int num_frames,enum
ieee80211_frame_release_type reason,bool more_data); int (*
get_et_sset_count) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif, int sset); void (* get_et_stats) (struct
ieee80211_hw *hw,struct ieee80211_vif *vif,struct
ethtool_stats *stats, u64 *data); void (* get_et_strings)
(struct ieee80211_hw *hw,struct ieee80211_vif *vif,u32 sset,
u8 *data); };</p>

<p>MEMBERS tx Handler that 802.11 module calls for each
transmitted frame. skb contains the buffer starting from the
IEEE 802.11 header. The low-level driver should send the
frame out based on configuration in the TX control data.
This handler should, preferably, never fail and stop queues
appropriately. This must be implemented if tx_frags is not.
Must be atomic.</p>

<p>tx_frags Called to transmit multiple fragments of a
single MSDU. This handler must consume all fragments,
sending out some of them only is useless and it can&acute;t
ask for some of them to be queued again. If the frame is not
fragmented the queue has a single SKB only. To avoid issues
with the networking stack when TX status is reported the
frames should be removed from the skb queue. If this is
used, the tx_info vif and sta pointers will be invalid --
you must not use them in that case. This must be implemented
if tx isn&acute;t. Must be atomic.</p>

<p>start Called before the first netdevice attached to the
hardware is enabled. This should turn on the hardware and
must turn on frame reception (for possibly enabled monitor
interfaces.) Returns negative error codes, these may be seen
in userspace, or zero. When the device is started it should
not have a MAC address to avoid acknowledging frames before
a non-monitor device is added. Must be implemented and can
sleep.</p>

<p>stop Called after last netdevice attached to the
hardware is disabled. This should turn off the hardware (at
least it must turn off frame reception.) May be called right
after add_interface if that rejects an interface. If you
added any work onto the mac80211 workqueue you should ensure
to cancel it on this callback. Must be implemented and can
sleep.</p>

<p>suspend Suspend the device; mac80211 itself will quiesce
before and stop transmitting and doing any other
configuration, and then ask the device to suspend. This is
only invoked when WoWLAN is configured, otherwise the device
is deconfigured completely and reconfigured at resume time.
The driver may also impose special conditions under which it
wants to use the normal suspend (deconfigure), say if it
only supports WoWLAN when the device is associated. In this
case, it must return 1 from this function.</p>

<p>resume If WoWLAN was configured, this indicates that
mac80211 is now resuming its operation, after this the
device must be fully functional again. If this returns an
error, the only way out is to also unregister the device. If
it returns 1, then mac80211 will also go through the regular
complete restart on resume.</p>

<p>set_wakeup Enable or disable wakeup when WoWLAN
configuration is modified. The reason is that
device_set_wakeup_enable is supposed to be called when the
configuration changes, not only in suspend.</p>

<p>add_interface Called when a netdevice attached to the
hardware is enabled. Because it is not called for monitor
mode devices, start and stop must be implemented. The driver
should perform any initialization it needs before the device
can be enabled. The initial configuration for the interface
is given in the conf parameter. The callback may refuse to
add an interface by returning a negative error code (which
will be seen in userspace.) Must be implemented and can
sleep.</p>

<p>change_interface Called when a netdevice changes type.
This callback is optional, but only if it is supported can
interface types be switched while the interface is UP. The
callback may sleep. Note that while an interface is being
switched, it will not be found by the interface iteration
callbacks.</p>

<p>remove_interface Notifies a driver that an interface is
going down. The stop callback is called after this if it is
the last interface and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the
hardware must be cleared so the device no longer
acknowledges packets, the mac_addr member of the conf
structure is, however, set to the MAC address of the device
going away. Hence, this callback must be implemented. It can
sleep.</p>

<p>config Handler for configuration requests. IEEE 802.11
code calls this function to change hardware configuration,
e.g., channel. This function should never fail but returns a
negative error code if it does. The callback can sleep.</p>

<p>bss_info_changed Handler for configuration requests
related to BSS parameters that may vary during BSS&acute;s
lifespan, and may affect low level driver (e.g.
assoc/disassoc status, erp parameters). This function should
not be used if no BSS has been set, unless for association
indication. The changed parameter indicates which of the bss
parameters has changed when a call is made. The callback can
sleep.</p>

<p>prepare_multicast Prepare for multicast filter
configuration. This callback is optional, and its return
value is passed to configure_filter. This callback must be
atomic.</p>

<p>configure_filter Configure the device&acute;s RX filter.
See the section Frame filtering for more information. This
callback must be implemented and can sleep.</p>

<p>set_tim Set TIM bit. mac80211 calls this function when a
TIM bit must be set or cleared for a given STA. Must be
atomic.</p>

<p>set_key See the section Hardware crypto acceleration
This callback is only called between add_interface and
remove_interface calls, i.e. while the given virtual
interface is enabled. Returns a negative error code if the
key can&acute;t be added. The callback can sleep.</p>

<p>update_tkip_key See the section Hardware crypto
acceleration This callback will be called in the context of
Rx. Called for drivers which set
IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY. The callback must be
atomic.</p>

<p>set_rekey_data If the device supports GTK rekeying, for
example while the host is suspended, it can assign this
callback to retrieve the data necessary to do GTK rekeying,
this is the KEK, KCK and replay counter. After rekeying was
done it should (for example during resume) notify userspace
of the new replay counter using
ieee80211_gtk_rekey_notify.</p>

<p>hw_scan Ask the hardware to service the scan request, no
need to start the scan state machine in stack. The scan must
honour the channel configuration done by the regulatory
agent in the wiphy&acute;s registered bands. The hardware
(or the driver) needs to make sure that power save is
disabled. The req ie/ie_len members are rewritten by
mac80211 to contain the entire IEs after the SSID, so that
drivers need not look at these at all but just send them
after the SSID -- mac80211 includes the (extended) supported
rates and HT information (where applicable). When the scan
finishes, ieee80211_scan_completed must be called; note that
it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error
code. The callback can sleep.</p>

<p>cancel_hw_scan Ask the low-level tp cancel the active hw
scan. The driver should ask the hardware to cancel the scan
(if possible), but the scan will be completed only after the
driver will call ieee80211_scan_completed. This callback is
needed for wowlan, to prevent enqueueing a new scan_work
after the low-level driver was already suspended. The
callback can sleep.</p>

<p>sched_scan_start Ask the hardware to start scanning
repeatedly at specific intervals. The driver must call the
ieee80211_sched_scan_results function whenever it finds
results. This process will continue until sched_scan_stop is
called.</p>

<p>sched_scan_stop Tell the hardware to stop an ongoing
scheduled scan.</p>

<p>sw_scan_start Notifier function that is called just
before a software scan is started. Can be NULL, if the
driver doesn&acute;t need this notification. The callback
can sleep.</p>

<p>sw_scan_complete Notifier function that is called just
after a software scan finished. Can be NULL, if the driver
doesn&acute;t need this notification. The callback can
sleep.</p>

<p>get_stats Return low-level statistics. Returns zero if
statistics are available. The callback can sleep.</p>

<p>get_tkip_seq If your device implements TKIP encryption
in hardware this callback should be provided to read the
TKIP transmit IVs (both IV32 and IV16) for the given key
from hardware. The callback must be atomic.</p>

<p>set_frag_threshold Configuration of fragmentation
threshold. Assign this if the device does fragmentation by
itself; if this callback is implemented then the stack will
not do fragmentation. The callback can sleep.</p>

<p>set_rts_threshold Configuration of RTS threshold (if
device needs it) The callback can sleep.</p>

<p>sta_add Notifies low level driver about addition of an
associated station, AP, IBSS/WDS/mesh peer etc. This
callback can sleep.</p>

<p>sta_remove Notifies low level driver about removal of an
associated station, AP, IBSS/WDS/mesh peer etc. This
callback can sleep.</p>

<p>sta_notify Notifies low level driver about power state
transition of an associated station, AP, IBSS/WDS/mesh peer
etc. For a VIF operating in AP mode, this callback will not
be called when the flag IEEE80211_HW_AP_LINK_PS is set. Must
be atomic.</p>

<p>sta_state Notifies low level driver about state
transition of a station (which can be the AP, a client,
IBSS/WDS/mesh peer etc.) This callback is mutually exclusive
with sta_add/sta_remove. It must not fail for down
transitions but may fail for transitions up the list of
states. The callback can sleep.</p>

<p>sta_rc_update Notifies the driver of changes to the
bitrates that can be used to transmit to the station. The
changes are advertised with bits from enum
ieee80211_rate_control_changed and the values are reflected
in the station data. This callback should only be used when
the driver uses hardware rate control
(IEEE80211_HW_HAS_RATE_CONTROL) since otherwise the rate
control algorithm is notified directly. Must be atomic.</p>

<p>conf_tx Configure TX queue parameters (EDCF (aifs,
cw_min, cw_max), bursting) for a hardware TX queue. Returns
a negative error code on failure. The callback can
sleep.</p>

<p>get_tsf Get the current TSF timer value from
firmware/hardware. Currently, this is only used for IBSS
mode BSSID merging and debugging. Is not a required
function. The callback can sleep.</p>

<p>set_tsf Set the TSF timer to the specified value in the
firmware/hardware. Currently, this is only used for IBSS
mode debugging. Is not a required function. The callback can
sleep.</p>

<p>reset_tsf Reset the TSF timer and allow
firmware/hardware to synchronize with other STAs in the
IBSS. This is only used in IBSS mode. This function is
optional if the firmware/hardware takes full care of TSF
synchronization. The callback can sleep.</p>

<p>tx_last_beacon Determine whether the last IBSS beacon
was sent by us. This is needed only for IBSS mode and the
result of this function is used to determine whether to
reply to Probe Requests. Returns non-zero if this device
sent the last beacon. The callback can sleep.</p>

<p>ampdu_action Perform a certain A-MPDU action The RA/TID
combination determines the destination and TID we want the
ampdu action to be performed for. The action is defined
through ieee80211_ampdu_mlme_action. Starting sequence
number (ssn) is the first frame we expect to perform the
action on. Notice that TX/RX_STOP can pass NULL for this
parameter. The buf_size parameter is only valid when the
action is set to IEEE80211_AMPDU_TX_OPERATIONAL and
indicates the peer&acute;s reorder buffer size (number of
subframes) for this session -- the driver may neither send
aggregates containing more subframes than this nor send
aggregates in a way that lost frames would exceed the buffer
size. If just limiting the aggregate size, this would be</p>

<p>get_survey Return per-channel survey information</p>

<p>rfkill_poll Poll rfkill hardware state. If you need
this, you also need to set wiphy-&gt;rfkill_poll to true
before registration, and need to call
wiphy_rfkill_set_hw_state in the callback. The callback can
sleep.</p>

<p>set_coverage_class Set slot time for given coverage
class as specified in IEEE 802.11-2007 section 17.3.8.6 and
modify ACK timeout accordingly. This callback is not
required and may sleep.</p>

<p>testmode_cmd Implement a cfg80211 test mode command. The
callback can sleep.</p>

<p>testmode_dump Implement a cfg80211 test mode dump. The
callback can sleep.</p>

<p>flush Flush all pending frames from the hardware queue,
making sure that the hardware queues are empty. If the
parameter drop is set to true, pending frames may be
dropped. The callback can sleep.</p>

<p>channel_switch Drivers that need (or want) to offload
the channel switch operation for CSAs received from the AP
may implement this callback. They must then call
ieee80211_chswitch_done to indicate completion of the
channel switch.</p>

<p>napi_poll Poll Rx queue for incoming data frames.</p>

<p>set_antenna Set antenna configuration (tx_ant, rx_ant)
on the device. Parameters are bitmaps of allowed antennas to
use for TX/RX. Drivers may reject TX/RX mask combinations
they cannot support by returning -EINVAL (also see nl80211.h
NL80211_ATTR_WIPHY_ANTENNA_TX).</p>

<p>get_antenna Get current antenna configuration from
device (tx_ant, rx_ant).</p>

<p>remain_on_channel Starts an off-channel period on the
given channel, must call back to ieee80211_ready_on_channel
when on that channel. Note that normal channel traffic is
not stopped as this is intended for hw offload. Frames to
transmit on the off-channel channel are transmitted normally
except for the IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
duration (which will always be non-zero) expires, the driver
must call ieee80211_remain_on_channel_expired. This callback
may sleep.</p>

<p>cancel_remain_on_channel Requests that an ongoing
off-channel period is aborted before it expires. This
callback may sleep.</p>

<p>set_ringparam Set tx and rx ring sizes.</p>

<p>get_ringparam Get tx and rx ring current and maximum
sizes.</p>

<p>tx_frames_pending Check if there is any pending frame in
the hardware queues before entering power save.</p>

<p>set_bitrate_mask Set a mask of rates to be used for rate
control selection when transmitting a frame. Currently only
legacy rates are handled. The callback can sleep.</p>

<p>rssi_callback Notify driver when the average RSSI goes
above/below thresholds that were registered previously. The
callback can sleep.</p>

<p>allow_buffered_frames Prepare device to allow the given
number of frames to go out to the given station. The frames
will be sent by mac80211 via the usual TX path after this
call. The TX information for frames released will also have
the IEEE80211_TX_CTL_NO_PS_BUFFER flag set and the last one
will also have IEEE80211_TX_STATUS_EOSP set. In case frames
from multiple TIDs are released and the driver might reorder
them between the TIDs, it must set the
IEEE80211_TX_STATUS_EOSP flag on the last frame and clear it
on all others and also handle the EOSP bit in the QoS header
correctly. Alternatively, it can also call the
ieee80211_sta_eosp_irqsafe function. The tids parameter is a
bitmap and tells the driver which TIDs the frames will be
on; it will at most have two bits set. This callback must be
atomic.</p>

<p>release_buffered_frames Release buffered frames
according to the given parameters. In the case where the
driver buffers some frames for sleeping stations mac80211
will use this callback to tell the driver to release some
frames, either for PS-poll or uAPSD. Note that if the
more_data paramter is false the driver must check if there
are more frames on the given TIDs, and if there are more
than the frames being released then it must still set the
more-data bit in the frame. If the more_data parameter is
true, then of course the more-data bit must always be set.
The tids parameter tells the driver which TIDs to release
frames from, for PS-poll it will always have only a single
bit set. In the case this is used for a PS-poll initiated
release, the num_frames parameter will always be 1 so code
can be shared. In this case the driver must also set
IEEE80211_TX_STATUS_EOSP flag on the TX status (and must
report TX status) so that the PS-poll period is properly
ended. This is used to avoid sending multiple responses for
a retried PS-poll frame. In the case this is used for uAPSD,
the num_frames parameter may be bigger than one, but the
driver may send fewer frames (it must send at least one,
however). In this case it is also responsible for setting
the EOSP flag in the QoS header of the frames. Also, when
the service period ends, the driver must set
IEEE80211_TX_STATUS_EOSP on the last frame in the SP.
Alternatively, it may call the function
ieee80211_sta_eosp_irqsafe to inform mac80211 of the end of
the SP. This callback must be atomic.</p>

<p>get_et_sset_count Ethtool API to get string-set
count.</p>

<p>get_et_stats Ethtool API to get a set of u64 stats.</p>

<p>get_et_strings Ethtool API to get a set of strings to
describe stats and perhaps other supported types of ethtool
data-sets.</p>

<p>DESCRIPTION This structure contains various callbacks
that the driver may handle or, in some cases, must handle,
for example to configure the hardware to a new channel or to
transmit a frame.</p>

<p>POSSIBLE WITH A BUF_SIZE OF 8 - TX: 1.....7 - RX: 2....7
(lost frame #1) - TX: 8..1... which is invalid since #1 was
now re-transmitted well past the buffer size of 8. Correct
ways to retransmit #1 would be: - TX: 1 or 18 or 81 Even 189
would be wrong since 1 could be lost again.</p>

<p>Returns a negative error code on failure. The callback
can sleep.</p>

<p>AUTHOR Johannes Berg &lt;johannes@sipsolutions.net&gt;
Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. January 2013 STRUCT
IEEE80211_OPS(9)</p>
<hr>
</body>
</html>
